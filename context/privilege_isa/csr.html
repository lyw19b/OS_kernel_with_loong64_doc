<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3.1. CSR寄存器 &mdash; 龙芯实验室文档 V1.0 文档</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=b01b2dd9" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />

  
    <link rel="shortcut icon" href="../../_static/favicon.jpg"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=3f0bcac8"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=f281be69"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
        <script src="../../_static/translations.js?v=beaddf03"></script>
        <script src="../../_static/design-tabs.js?v=f930bc37"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="3.4. CPUCFG 指令" href="cacop_insn.html" />
    <link rel="prev" title="3. 特权态指令" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <img src="../../_static/logo.svg" class="logo" alt="Logo"/>
          <a href="../../index.html" class="icon icon-home">
            龙芯实验室文档
          </a>
              <div class="version">
                V1.0
              </div>
<div role="search">
  <form id="evas-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../preparation/index.html">1. 准备工作</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../preparation/preface.html">1.1. 前言</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../preparation/preface.html#id2">1.1.1. 更新说明</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/preface.html#id3">1.1.2. 仓库地址</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../preparation/tools.html">1.2. 工具链说明</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#gcc">1.2.1. GCC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#llvm">1.2.2. LLVM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#rust">1.2.3. Rust</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../preparation/tools.html#id2">1.3. 模拟器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#qemu">1.3.1. QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#la-emu">1.3.2. LA_EMU</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../preparation/tools.html#id3">1.4. 操作系统编译</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#loongnix">1.4.1. LoongNix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#uos">1.4.2. UOS</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#deepin">1.4.3. Deepin</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#aosc">1.4.4. AOSC(安同)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#linux-kernel">1.4.5. Linux kernel</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../toolchains/index.html">2. 工具链</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/gcc.html">2.1. GCC</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/gcc.html#id1">2.1.1. GCC的相关概念</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id2">2.1.1.1. GCC的基本定义与起源</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id4">2.1.1.2. GCC支持的语言与平台</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id5">2.1.1.3. GCC的核心功能与特点</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id6">2.1.1.4. GCC的最新进展</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id7">2.1.1.5. GCC的应用场景</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/gcc.html#id8">2.1.2. 交叉编译器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/gcc.html#id9">2.1.3. 常见的类别组合</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/gcc.html#id12">2.1.4. 如何编译交叉编译器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#loongarch64-linux-gnu-sf">2.1.4.1. 如何编译loongarch64-linux-gnu[sf]</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#loongarch64-linux-musl-sf">2.1.4.2. 如何编译loongarch64-linux-musl[sf]</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#crtn-crti-crtbegin-crtend">2.1.4.3. crtn, crti, crtbegin, crtend有什么区别</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/gcc.html#id22">2.1.5. 常用的参数与选项</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id23">2.1.5.1. GCC常见的参数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#picpie">2.1.5.2. PIC与PIE的区别是什么</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#loongarch">2.1.5.3. 与LoongArch相关的选项说明</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#c-c">2.1.5.4. C/C++ 预处理器内嵌的宏定义</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/binutils.html">2.2. Binutils</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/binutils.html#gnu-binutils">2.2.1. GNU Binutils的相关说明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id1">2.2.1.1. <strong>核心定位与背景</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id2">2.2.1.2. <strong>重要组成部分与功能</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id5">2.2.1.3. <strong>应用场景</strong></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/binutils.html#ld">2.2.2. ld链接器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id6">2.2.2.1. LD的参数说明</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/binutils.html#readelf">2.2.3. 如何正确的使用readelf</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id7">2.2.3.1. 基础用法与核心选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id11">2.2.3.2. 二、高级用法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id14">2.2.3.3. 三、实战示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id18">2.2.3.4. 四、与其他工具对比</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/binutils.html#objdump">2.2.4. objdump</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id19">2.2.4.1. 一、基础用法与核心选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id25">2.2.4.2. 二、高级用法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id31">2.2.4.3. 三、典型应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id36">2.2.4.4. 四、与其他工具对比</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id37">2.2.4.5. 五、注意事项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id38">2.2.4.6. 六、实战示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/binutils.html#objcopy">2.2.5. objcopy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id42">2.2.5.1. 一、基础用法与核心选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id46">2.2.5.2. 二、高级功能</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id51">2.2.5.3. 三、参数详解</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id52">2.2.5.4. 四、典型应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id56">2.2.5.5. 五、常见问题与解决</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id60">2.2.5.6. 六、与其他工具对比</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id61">2.2.5.7. 七、总结</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/rust.html">2.3. Rust</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/rust.html#id1">2.3.1. Rust的概念</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/rust.html#id2">2.3.1.1. Rust的起源与发展</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/rust.html#id3">2.3.1.2. Rust的核心特性</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/rust.html#id4">2.3.1.3. Rust的应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/rust.html#id5">2.3.1.4. Rust的最新进展</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/rust.html#id6">2.3.1.5. Rust的优缺点</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/rust.html#loongarchtarget">2.3.2. LoongArch支持的target有哪些</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/rust.html#loongarch">2.3.3. 与LoongArch相关的具体参数那些</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/rust.html#laexe">2.3.4. 简单的例子说明如何编译成LA架构的EXE文件</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/builtin.html">2.4. 内嵌的函数与指令包装</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/builtin.html#gcc">2.4.1. GCC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/builtin.html#llvm">2.4.2. LLVM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/builtin.html#rust">2.4.3. Rust</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/builtin.html#loongarch">2.4.3.1. LoongArch包的相关内容</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/assembly.html">2.5. 汇编代码与链接脚本</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/assembly.html#loongarch">2.5.1. 与LoongArch相关的汇编指令</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id2">2.5.1.1. 伪汇编指令</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id3">2.5.1.2. 地址加载指令</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id4">2.5.1.3. 内嵌汇编</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id5">2.5.1.4. 参考阅读</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/assembly.html#id6">2.5.2. 链接脚本</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id7">2.5.2.1. 一、基础语法结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id8">2.5.2.2. 二、核心命令与操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id13">2.5.2.3. 三、高级功能</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id17">2.5.2.4. 四、典型应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id21">2.5.2.5. 五、实战示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id24">2.5.2.6. 六、调试与验证</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id25">2.5.2.7. 七、总结</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id26">2.5.2.8. 以LoongArch为例说明链接脚本</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/library.html">2.6. 一些常用的库函数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/library.html#glibc">2.6.1. GLIBC</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id2">2.6.1.1. 一、核心功能与作用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id3">2.6.1.2. 二、架构与实现细节</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id4">2.6.1.3. 三、版本演进与升级风险</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id5">2.6.1.4. 四、与其他运行库的对比</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id6">2.6.1.5. 五、开发与调试工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/library.html#musl">2.6.2. MUSL</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#musl-c">2.6.2.1. Musl C 库详解</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id15">2.6.2.2. 总结</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/library.html#memcpy">2.6.3. memcpy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/library.html#memmove">2.6.4. memmove</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/library.html#memset">2.6.5. memset</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">3. 特权态指令</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">3.1. CSR寄存器</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id1">3.2. CSR指令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#csrrd">3.2.1. CSRRD指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="#csrwr">3.2.2. CSRWR指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="#csrxchg">3.2.3. CSRXCHG指令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#iocsr">3.3. IOCSR指令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#iocsrrd">3.3.1. IOCSRRD指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iocsrwr">3.3.2. IOCSRWR指令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="cacop_insn.html">3.4. CPUCFG 指令</a></li>
<li class="toctree-l2"><a class="reference internal" href="cacop_insn.html#cacop">3.5. CACOP 指令</a></li>
<li class="toctree-l2"><a class="reference internal" href="tlb_insn.html">3.6. TLB 与页表指令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tlb_insn.html#id1">3.6.1. TLB 相关指令</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tlb_insn.html#tlbsrch">3.6.1.1. TLBSRCH</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_insn.html#tlbrd">3.6.1.2. TLBRD</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_insn.html#tlbwr">3.6.1.3. TLBWR</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_insn.html#tlbfill">3.6.1.4. TLBFILL</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_insn.html#tlbclr">3.6.1.5. TLBCLR</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_insn.html#tlbflush">3.6.1.6. TLBFLUSH</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_insn.html#invtlb">3.6.1.7. INVTLB</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="tlb_insn.html#id2">3.6.2. 页表查找指令</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tlb_insn.html#lddir">3.6.2.1. LDDIR</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_insn.html#ldpte">3.6.2.2. LDPTE</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="tlb_insn.html#id3">3.6.3. 应用示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="misc_insn.html">3.7. ERTN指令</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_insn.html#idle">3.8. IDLE指令</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc_insn.html#syscall">3.9. SysCALL指令</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../mmu/index.html">4. 内存管理</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../mmu/tlb_struct.html">4.1. LoongArch的地址管理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_struct.html#id2">4.1.1. 直接地址翻译模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_struct.html#id3">4.1.2. 映射地址翻译模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_struct.html#id4">4.1.3. 存储访问的类型</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../mmu/tlb_struct.html#loongarchtlb">4.2. LoongArch的TLB结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_struct.html#id5">4.2.1. 逻辑组织结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_struct.html#tlb-cpu">4.2.2. TLB的表项（以CPU的视觉）</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../mmu/tlb_struct.html#tlb">4.3. TLB的管理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_struct.html#id6">4.3.1. TLB的一些概念区分</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_struct.html#id7">4.3.2. TLB相关的指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_struct.html#tlbcsr">4.3.3. TLB相关的CSR</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_struct.html#tlb-excption-handle">4.3.4. TLB相关的例外</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_struct.html#cputlb">4.3.5. CPU内部TLB查找流程示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../mmu/dmw.html">4.4. 直接映射翻译模式</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../mmu/dmw.html#csr-dmw-0-3">4.4.1. CSR.DMW[0-3]</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/dmw.html#id2">4.4.2. 操作系统中如何使用</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../mmu/dmw.html#dmw">4.4.2.1. DMW的优点</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/dmw.html#id3">4.4.2.2. DMW的缺点</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/dmw.html#id4">4.4.2.3. 代码示例如何在内核中使用</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../mmu/tlb_ptw.html">4.5. 多级页表结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_ptw.html#id2">4.5.1. 设计背景与必要性</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id3">4.5.1.1. 多级页表的结构与层级</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id4">4.5.1.2. 地址转换流程</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id5">4.5.1.3. 多级页表的优势</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id6">4.5.1.4. 优化机制</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id7">4.5.1.5. 对比不同架构的页表设计</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_ptw.html#loongarch">4.5.2. LoongArch的多级页表结构</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#kernel">4.5.2.1. Kernel如何初始化设置多级页表结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#kb">4.5.2.2. 二级页表，4KB页大小</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id8">4.5.2.3. 二级页表，16KB页大小</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id9">4.5.2.4. 三级页表，4KB页大小</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id10">4.5.2.5. 三级页表，16KB页大小</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id11">4.5.2.6. 四级页表，4KB页大小</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id12">4.5.2.7. 四级页表，16KB页大小</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_ptw.html#id13">4.5.3. 内存中的页表表项（Kernel视角）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id14">4.5.3.1. 基本页表（叶子节点）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id15">4.5.3.2. 大页页表（叶子节点）</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#no-leaf-pg-entry">4.5.3.3. 中间指向下一级目录的地址的页表(非叶子节点页表)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_ptw.html#id17">4.5.4. 页表的遍历</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#k">4.5.4.1. 以一个例子4K页为例说明：</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#m">4.5.4.2. 以一个例子2M页为例说明：</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../mmu/tlb_ptw.html#cputlb">4.6. 从内存中的页表表项到CPU中的TLB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_ptw.html#tlbrefill-softeware-ptw">4.6.1. TLBRefill (Softeware PTW)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#csr">4.6.1.1. 相关的CSR寄存器</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id18">4.6.1.2. 重填示例代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id19">4.6.1.3. 两级页表的示例代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#three-level-page-table-refill">4.6.1.4. 三级页表的示例代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id21">4.6.1.5. 四级页表的示例代码</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_ptw.html#hardware-ptw">4.6.2. Hardware PTW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/tlb_ptw.html#id22">4.6.3. 页表的刷新</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id23">4.6.3.1. 页表为什么需要刷新</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id24">4.6.3.2. 页表刷新的指令</a></li>
<li class="toctree-l4"><a class="reference internal" href="../mmu/tlb_ptw.html#id25">4.6.3.3. 页表刷新的例子</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../mmu/page_table_in_kernel.html">4.7. Kernel与MMU</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../mmu/page_table_in_kernel.html#id1">4.7.1. 地址翻译相关的初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/page_table_in_kernel.html#id2">4.7.2. 如何从直接地址翻译模式到映射地址翻译模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/page_table_in_kernel.html#id3">4.7.3. 如何建立虚拟地址到物理地址的映射关系</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/page_table_in_kernel.html#id4">4.7.4. 页表的遍历页表</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/page_table_in_kernel.html#tlb">4.7.5. 情况1. 如果TLB中没有映射</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/page_table_in_kernel.html#v-0">4.7.6. 情况2. 如果页表项的V=0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/page_table_in_kernel.html#d-0">4.7.7. 情况3. 如果写操作页表项D=0</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/page_table_in_kernel.html#id5">4.7.8. 情况4. 如果权限不合法</a></li>
<li class="toctree-l3"><a class="reference internal" href="../mmu/page_table_in_kernel.html#ptw">4.7.9. 如果使能硬件PTW</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../trap/index.html">5. 中断与异常系统</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../trap/interrupt.html">5.1. 中断</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id2">5.1.1. 线中断</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#ipi">5.1.1.1. 核间中断IPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id3">5.1.1.2. 定时器中断</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id4">5.1.1.3. 性能计数器中断</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id5">5.1.1.4. 外部硬中断</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id6">5.1.1.5. 内部软中断</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id7">5.1.1.6. 中断号</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id8">5.1.2. 消息中断</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id9">5.1.3. 中断的优先级</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id10">5.1.3.1. 线中断的优先级</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id11">5.1.3.2. 消息中断的优先级</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id12">5.1.4. 中断的打开与关闭</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id13">5.1.5. 中断的入口地址</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id14">5.1.6. 中断的处理流程</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../trap/exception.html">5.2. 例外</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../trap/exception.html#id2">5.2.1. 例外的优先级</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/exception.html#id3">5.2.2. 例外的入口地址</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/exception.html#id4">5.2.3. 例外的处理过程</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../trap/exception.html#id5">5.2.3.1. 普通例外的处理过程</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/exception.html#tlb">5.2.3.2. TLB 重填例外硬件处理过程</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/exception.html#id6">5.2.3.3. 机器错误例外硬件处理过程</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../trap/trap_in_kernel.html">5.3. Kernel与异常</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#expection-entry-selection">5.3.1. 异常的入口地址选择</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../trap/trap_in_kernel.html#id2">5.3.1.1. “统一式”的入口地址</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/trap_in_kernel.html#id3">5.3.1.2. “分离式”的入口地址</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#id4">5.3.2. 异常的初始化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../trap/trap_in_kernel.html#id5">5.3.2.1. 统一式的初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/trap_in_kernel.html#id7">5.3.2.2. 分离式的初始化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#cpu">5.3.3. 异常发生时，CPU做了什么</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../trap/trap_in_kernel.html#id9">5.4. 特殊异常的处理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#id10">5.4.1. 定时器中断</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#id11">5.4.2. 系统调用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#id12">5.4.3. 非对齐访问</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../smp/index.html">6. SMP多核系统</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../smp/smp.html">6.1. SMP与LoongArch</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../smp/smp.html#ipi">6.1.1. IPI中断</a></li>
<li class="toctree-l3"><a class="reference internal" href="../smp/smp.html#id1">6.1.2. 如何通信</a></li>
<li class="toctree-l3"><a class="reference internal" href="../smp/smp.html#id2">6.1.3. 如何初始化</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../smp/smp.html#linuxsmp">6.2. Linux中SMP的处理（与架构相关）</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../abi/index.html">7. 程序二进制接口</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../abi/new_and_old_world.html">7.1. 新旧世界</a></li>
<li class="toctree-l2"><a class="reference internal" href="../abi/new_and_old_world.html#id2">7.2. 旧世界</a></li>
<li class="toctree-l2"><a class="reference internal" href="../abi/new_and_old_world.html#id3">7.3. 新世界</a></li>
<li class="toctree-l2"><a class="reference internal" href="../abi/new_and_old_world.html#id4">7.4. 新旧世界的区分</a></li>
<li class="toctree-l2"><a class="reference internal" href="../abi/abi.html">7.5. ABI 2.0</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../debug/index.html">8. 调试方法与技巧</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../debug/debug_env.html">8.1. LoongArch最小debug环境搭建</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_env.html#linux-ramdisk">8.1.1. 制作Linux RamDisk</a></li>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_env.html#qemu">8.1.2. 如何在 QEMU 中调试</a></li>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_env.html#id1">8.1.3. 设置断点</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../debug/debug_gdb.html">8.2. GDB的使用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_gdb.html#id1">8.2.1. 交叉编译环境中的GDB</a></li>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_gdb.html#id2">8.2.2. 常见的GDB命令示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_gdb.html#id3">8.2.3. 调试指令常见失效状况</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../platform/index.html">9. 平台相关</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../platform/qemu.html">9.1. QEMU</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/qemu.html#virt">9.1.1. Virt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/qemu.html#id1">9.1.2. 设备</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/3a5000.html">9.2. 3A5000芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/3a5000.html#id1">9.2.1. 芯片参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/3a5000.html#id2">9.2.2. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/3a5000.html#id3">9.2.3. 地址空间</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../platform/3a5000.html#id4">9.2.3.1. 结点间物理地址空间</a></li>
<li class="toctree-l4"><a class="reference internal" href="../platform/3a5000.html#id5">9.2.3.2. 结点内物理地址空间</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/3a6000.html">9.3. 3A6000芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/3a6000.html#id1">9.3.1. 芯片参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/3a6000.html#id2">9.3.2. 芯片架构</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/2k3000.html">9.4. 2k3000芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k3000.html#id1">9.4.1. 芯片参数</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/2k1000la.html">9.5. 2k1000LA芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k1000la.html#id1">9.5.1. 芯片参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k1000la.html#id2">9.5.2. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k1000la.html#id3">9.5.3. 芯片功能</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k1000la.html#id4">9.5.4. 地址空间</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/2k0500.html">9.6. 2k0500芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id1">9.6.1. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id2">9.6.2. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id3">9.6.3. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id4">9.6.4. 芯片功能</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id5">9.6.5. 地址空间</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id6">9.6.6. 中断配置</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/2k0300.html">9.7. 2k0300芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0300.html#id1">9.7.1. 芯片参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0300.html#id2">9.7.2. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0300.html#id3">9.7.3. 芯片功能</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0300.html#id4">9.7.4. 地址空间</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0300.html#id5">9.7.5. 中断配置及路由</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../simd/index.html">10. 高级应用：SMID与向量指令</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../simd/todo.html">10.1. TODO</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">11. 高级应用：LVZ与虚拟化扩展</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../virt/todo.html">11.1. TODO</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">12. FAQ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../faq/faq-25.html">12.1. FAQ-25</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">龙芯实验室文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html"><span class="section-number">3. </span>特权态指令</a></li>
      <li class="breadcrumb-item active"><span class="section-number">3.1. </span>CSR寄存器</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="csr">
<h1><span class="section-number">3.1. </span>CSR寄存器<a class="headerlink" href="#csr" title="Link to this heading"></a></h1>
<p>控制状态寄存器 CSR 是 CPU 内部一组特殊的、具有特定功能的寄存器，是操作系统内核与 CPU 硬件进行控制、状态监控和配置交互的核心硬件接口。</p>
<p>与通用寄存器不同，CSR 数量有限，并且每个 CSR 都有明确的专用功能，可以用来实现执行流控制，管理中断与异常，实现性能检测等功能。</p>
<p>因此，CSR 有独立的地址编号，并以此编号作为查找 CSR 的索引地址——基本寻址单位为一个 CSR 宽度。依靠不同的 CSR ，操作系统才能实现软件的隔离保护、调度并发，以及中断响应。</p>
<p>CSR 大致分为两类:</p>
<ul class="simple">
<li><p>控制类。操作系统通过写入这些 CSR 来命令 CPU 改变其行为或配置。例如：写入 CSR.CRMD 的 IE 位来开启或关闭全局中断。</p></li>
<li><p>状态类。CPU 硬件通过更新这些 CSR 来报告其内部状态或事件，操作系统通过读取它们来了解情况。例如：当发生例外时，CPU 会将异常原因代码自动写入 CSR.ESTAT 的 ECode 字段，并将出错地址写入 CSR.BADV。</p></li>
</ul>
<p>另外，访问 CSR 需要特殊的指令，如 LoongArch 中的 CSRWR（写）、CSRRD（读）、CSRXCHG（交换），这保证了只有拥有足够特权级（如操作系统内核）才能操作它们，是安全性的基石，文档将在 3.2 章详细介绍这些特权指令。</p>
<p>LoongArch架构包含的状态控制寄存器 CSR ，其具体含义如下。</p>
<table class="docutils align-default" id="id2">
<caption><span class="caption-text">状态控制寄存器</span><a class="headerlink" href="#id2" title="Link to this table"></a></caption>
<colgroup>
<col style="width: 30.0%" />
<col style="width: 40.0%" />
<col style="width: 30.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>地址</strong></p></th>
<th class="head"><p><strong>全名</strong></p></th>
<th class="head"><p><strong>缩写名称</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0x0</p></td>
<td><p>当前模式信息</p></td>
<td><p>CRMD</p></td>
</tr>
<tr class="row-odd"><td><p>0x1</p></td>
<td><p>例外前模式信息</p></td>
<td><p>PRMD</p></td>
</tr>
<tr class="row-even"><td><p>0x2</p></td>
<td><p>扩展部件使能</p></td>
<td><p>EUEN</p></td>
</tr>
<tr class="row-odd"><td><p>0x3</p></td>
<td><p>杂项控制</p></td>
<td><p>MISC</p></td>
</tr>
<tr class="row-even"><td><p>0x4</p></td>
<td><p>例外配置</p></td>
<td><p>ECFG</p></td>
</tr>
<tr class="row-odd"><td><p>0x5</p></td>
<td><p>例外状态</p></td>
<td><p>ESTAT</p></td>
</tr>
<tr class="row-even"><td><p>0x6</p></td>
<td><p>例外返回地址</p></td>
<td><p>ERA</p></td>
</tr>
<tr class="row-odd"><td><p>0x7</p></td>
<td><p>出错虚拟地址</p></td>
<td><p>BADV</p></td>
</tr>
<tr class="row-even"><td><p>0x8</p></td>
<td><p>出错指令</p></td>
<td><p>BADI</p></td>
</tr>
<tr class="row-odd"><td><p>0xC</p></td>
<td><p>例外入口点地址</p></td>
<td><p>EENTRY</p></td>
</tr>
<tr class="row-even"><td><p>0x10</p></td>
<td><p>TLB 索引</p></td>
<td><p>TLBIDX</p></td>
</tr>
<tr class="row-odd"><td><p>0x11</p></td>
<td><p>TLB 表项高位</p></td>
<td><p>TLBEHI</p></td>
</tr>
<tr class="row-even"><td><p>0x12</p></td>
<td><p>TLB 表项低位 0</p></td>
<td><p>TLBELO0</p></td>
</tr>
<tr class="row-odd"><td><p>0x13</p></td>
<td><p>TLB 表项低位 1</p></td>
<td><p>TLBELO1</p></td>
</tr>
<tr class="row-even"><td><p>0x18</p></td>
<td><p>地址空间标识符</p></td>
<td><p>ASID</p></td>
</tr>
<tr class="row-odd"><td><p>0x19</p></td>
<td><p>低半地址空间的全局目录地址</p></td>
<td><p>PGDL</p></td>
</tr>
<tr class="row-even"><td><p>0x1A</p></td>
<td><p>高半地址空间的全局目录地址</p></td>
<td><p>PGDH</p></td>
</tr>
<tr class="row-odd"><td><p>0x1B</p></td>
<td><p>全局目录地址</p></td>
<td><p>PGD</p></td>
</tr>
<tr class="row-even"><td><p>0x1C</p></td>
<td><p>页面遍历控制低半部分</p></td>
<td><p>PWCL</p></td>
</tr>
<tr class="row-odd"><td><p>0x1D</p></td>
<td><p>页面遍历控制高半部分</p></td>
<td><p>PWCH</p></td>
</tr>
<tr class="row-even"><td><p>0x1E</p></td>
<td><p>STLB 页大小</p></td>
<td><p>STLBPS</p></td>
</tr>
<tr class="row-odd"><td><p>0x1F</p></td>
<td><p>缩减虚地址配置</p></td>
<td><p>RVACFG</p></td>
</tr>
<tr class="row-even"><td><p>0x20</p></td>
<td><p>CPU 标识符</p></td>
<td><p>CPUID</p></td>
</tr>
<tr class="row-odd"><td><p>0x21</p></td>
<td><p>特权资源配置信息 1</p></td>
<td><p>PRCFG1</p></td>
</tr>
<tr class="row-even"><td><p>0x22</p></td>
<td><p>特权资源配置信息 2</p></td>
<td><p>PRCFG2</p></td>
</tr>
<tr class="row-odd"><td><p>0x23</p></td>
<td><p>特权资源配置信息 3</p></td>
<td><p>PRCFG3</p></td>
</tr>
<tr class="row-even"><td><p>0x30+n (0≤n≤15)</p></td>
<td><p>数据保存</p></td>
<td><p>SAVEn</p></td>
</tr>
<tr class="row-odd"><td><p>0x40</p></td>
<td><p>定时器编号</p></td>
<td><p>TID</p></td>
</tr>
<tr class="row-even"><td><p>0x41</p></td>
<td><p>定时器配置</p></td>
<td><p>TCFG</p></td>
</tr>
<tr class="row-odd"><td><p>0x42</p></td>
<td><p>定时器值</p></td>
<td><p>TVAL</p></td>
</tr>
<tr class="row-even"><td><p>0x43</p></td>
<td><p>计时器补偿</p></td>
<td><p>CNTC</p></td>
</tr>
<tr class="row-odd"><td><p>0x44</p></td>
<td><p>定时器中断清除</p></td>
<td><p>TICLR</p></td>
</tr>
<tr class="row-even"><td><p>0x60</p></td>
<td><p>LLBit 控制</p></td>
<td><p>LLBCTL</p></td>
</tr>
<tr class="row-odd"><td><p>0x80</p></td>
<td><p>实现相关控制 1</p></td>
<td><p>IMPCTL1</p></td>
</tr>
<tr class="row-even"><td><p>0x81</p></td>
<td><p>实现相关控制 2</p></td>
<td><p>IMPCTL2</p></td>
</tr>
<tr class="row-odd"><td><p>0x88</p></td>
<td><p>TLB 重填例外入口地址</p></td>
<td><p>TLBRENTRY</p></td>
</tr>
<tr class="row-even"><td><p>0x89</p></td>
<td><p>TLB 重填例外出错虚拟地址</p></td>
<td><p>TLBRBADV</p></td>
</tr>
<tr class="row-odd"><td><p>0x8A</p></td>
<td><p>TLB 重填例外返回地址</p></td>
<td><p>TLBRERA</p></td>
</tr>
<tr class="row-even"><td><p>0x8B</p></td>
<td><p>TLB 重填例外数据保存</p></td>
<td><p>TLBRSAVE</p></td>
</tr>
<tr class="row-odd"><td><p>0x8C</p></td>
<td><p>TLB 重填例外表项低位 0</p></td>
<td><p>TLBRELO0</p></td>
</tr>
<tr class="row-even"><td><p>0x8D</p></td>
<td><p>TLB 重填例外表项低位 1</p></td>
<td><p>TLBRELO1</p></td>
</tr>
<tr class="row-odd"><td><p>0x8E</p></td>
<td><p>TLB 重填例外表象高位</p></td>
<td><p>TLBEHI</p></td>
</tr>
<tr class="row-even"><td><p>0x8F</p></td>
<td><p>TLB 重填例外前模式信息</p></td>
<td><p>TLBRPRMD</p></td>
</tr>
<tr class="row-odd"><td><p>0x90</p></td>
<td><p>机器错误控制</p></td>
<td><p>MERRCTL</p></td>
</tr>
<tr class="row-even"><td><p>0x91</p></td>
<td><p>机器错误信息 1</p></td>
<td><p>MERRINFO1</p></td>
</tr>
<tr class="row-odd"><td><p>0x92</p></td>
<td><p>机器错误信息 2</p></td>
<td><p>MERRINFO2</p></td>
</tr>
<tr class="row-even"><td><p>0x93</p></td>
<td><p>机器错误例外入口地址</p></td>
<td><p>MERRENTRY</p></td>
</tr>
<tr class="row-odd"><td><p>0x94</p></td>
<td><p>机器错误例外返回地址</p></td>
<td><p>MERRERA</p></td>
</tr>
<tr class="row-even"><td><p>0x95</p></td>
<td><p>机器错误例外数据保存</p></td>
<td><p>MERRSAVE</p></td>
</tr>
<tr class="row-odd"><td><p>0x98</p></td>
<td><p>高速缓存标签</p></td>
<td><p>CTAG</p></td>
</tr>
<tr class="row-even"><td><p>0xa0</p></td>
<td><p>消息中断状态 0</p></td>
<td><p>MSGIS0</p></td>
</tr>
<tr class="row-odd"><td><p>0xa1</p></td>
<td><p>消息中断状态 1</p></td>
<td><p>MSGIS1</p></td>
</tr>
<tr class="row-even"><td><p>0xa2</p></td>
<td><p>消息中断状态 2</p></td>
<td><p>MSGIS2</p></td>
</tr>
<tr class="row-odd"><td><p>0xa3</p></td>
<td><p>消息中断状态 3</p></td>
<td><p>MSGIS3</p></td>
</tr>
<tr class="row-even"><td><p>0xa4</p></td>
<td><p>消息中断请求</p></td>
<td><p>MSGIR</p></td>
</tr>
<tr class="row-odd"><td><p>0xa5</p></td>
<td><p>消息中断使能</p></td>
<td><p>MSGIE</p></td>
</tr>
<tr class="row-even"><td><p>0x180+n (0≤n≤3)</p></td>
<td><p>直接映射配置窗口 n</p></td>
<td><p>DMWn</p></td>
</tr>
<tr class="row-odd"><td><p>0x200+2n (0≤n≤31)</p></td>
<td><p>性能监测配置 n</p></td>
<td><p>PMCFGn</p></td>
</tr>
<tr class="row-even"><td><p>0x201+2n (0≤n≤31)</p></td>
<td><p>性能监测计数器 n</p></td>
<td><p>PMCNTn</p></td>
</tr>
<tr class="row-odd"><td><p>0x300</p></td>
<td><p>load/store 监视点整体控制</p></td>
<td><p>MWPC</p></td>
</tr>
<tr class="row-even"><td><p>0x301</p></td>
<td><p>load/store 监视点整体状态</p></td>
<td><p>MWPS</p></td>
</tr>
<tr class="row-odd"><td><p>0x310+8n (0≤n≤7)</p></td>
<td><p>load/store 监视点 n 配置 1</p></td>
<td><p>MWPnCFG1</p></td>
</tr>
<tr class="row-even"><td><p>0x311+8n (0≤n≤7)</p></td>
<td><p>load/store 监视点 n 配置 2</p></td>
<td><p>MWPnCFG2</p></td>
</tr>
<tr class="row-odd"><td><p>0x312+8n (0≤n≤7)</p></td>
<td><p>load/store 监视点 n 配置 3</p></td>
<td><p>MWPnCFG3</p></td>
</tr>
<tr class="row-even"><td><p>0x313+8n (0≤n≤7)</p></td>
<td><p>load/store 监视点 n 配置 4</p></td>
<td><p>MWPnCFG4</p></td>
</tr>
<tr class="row-odd"><td><p>0x380</p></td>
<td><p>取指监视点整体控制</p></td>
<td><p>FWPC</p></td>
</tr>
<tr class="row-even"><td><p>0x381</p></td>
<td><p>取指监视点整体状态</p></td>
<td><p>FWPS</p></td>
</tr>
<tr class="row-odd"><td><p>0x390+8n (0≤n≤7)</p></td>
<td><p>取指监视点 n 配置 1</p></td>
<td><p>FWPnCFG1</p></td>
</tr>
<tr class="row-even"><td><p>0x391+8n (0≤n≤7)</p></td>
<td><p>取指监视点 n 配置 2</p></td>
<td><p>FWPnCFG2</p></td>
</tr>
<tr class="row-odd"><td><p>0x392+8n (0≤n≤7)</p></td>
<td><p>取指监视点 n 配置 3</p></td>
<td><p>FWPnCFG3</p></td>
</tr>
<tr class="row-even"><td><p>0x393+8n (0≤n≤7)</p></td>
<td><p>取指监视点 n 配置 4</p></td>
<td><p>FWPnCFG4</p></td>
</tr>
<tr class="row-odd"><td><p>0x500</p></td>
<td><p>调试寄存器</p></td>
<td><p>DBG</p></td>
</tr>
<tr class="row-even"><td><p>0x501</p></td>
<td><p>调试例外返回地址</p></td>
<td><p>DERA</p></td>
</tr>
<tr class="row-odd"><td><p>0x502</p></td>
<td><p>调试数据保存</p></td>
<td><p>DSAVE</p></td>
</tr>
</tbody>
</table>
<p>CSR 具体含义可参考《龙芯架构参考手册卷一》7 章节。</p>
</section>
<section id="id1">
<h1><span class="section-number">3.2. </span>CSR指令<a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
<p>CSR 指令用于软件访问和修改 CSR 。</p>
<p>这组指令仅在 PLV0 特权等级下才能访问。仅有一个例外情况，当 CSR.MISC 中的 RPCNTL1/RPCNTL2/RPCNTL3 配置为1时，可以在 PLV1/PLV2/PLV3 特权等级下执行 CSRRD 指令，读取性能计数器。</p>
<section id="csrrd">
<h2><span class="section-number">3.2.1. </span>CSRRD指令<a class="headerlink" href="#csrrd" title="Link to this heading"></a></h2>
<p>格式: <code class="docutils literal notranslate"><span class="pre">csrrd</span> <span class="pre">	rd,csr_num</span></code></p>
<p>操作:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>GPR[rd] &lt;- CSR[csr_num]
</pre></div>
</div>
<p>CSRRD 指令将指定 CSR 的值写入到通用寄存器 rd 中。</p>
<p>其中，csr_num 是 14 比特立即数，用来描述目标 CSR 的编号，其对应关系可查看 3.1 章节对应关系表格。举例来说，当 csr_num 值为 8 时，在表格中查询地址为 8 的表格项，找到其对应名称为 BADI ，表明该指令的目标 CSR 为 BADI ，指令为获取出错指令信息。</p>
<p>所有 CSR 寄存器的位宽可能是 32 位宽，或者与架构中的通用寄存器 GR 等宽，因此 CSR 指令不区分位宽。
在 LA32 架构下，所有 CSR 寄存器都是 32 位宽。在 LA64 架构下，定义中宽度固定为 32 位的 CSR ，需要符号扩展后写入到通用寄存器 rd 中。</p>
<p>当 CSRRD 指令访问一个架构中未定义或硬件未实现的 CSR 时，操作可能返回任意值。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在模拟器 LA_EMU 中可查看 CSRRD 指令的模拟实现。</p>
<p>在<code class="docutils literal notranslate"><span class="pre">LA_EMU/loongarch64/interpreter.c</span></code>中，可以查看如下函数实现:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">helper_read_csr</span><span class="p">(</span><span class="n">CPULoongArchState</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">csr_index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">old_v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">csr_index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">LOONGARCH_CSR_CRMD</span><span class="w">           </span><span class="p">:</span><span class="n">old_v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">CSR_CRMD</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">LOONGARCH_CSR_PRMD</span><span class="w">           </span><span class="p">:</span><span class="n">old_v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">CSR_PRMD</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//	...</span>
<span class="w">        </span><span class="k">default</span><span class="o">:</span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;NOT IMPLEMENTED %s %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">__func__</span><span class="p">,</span><span class="w"> </span><span class="n">csr_index</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">old_v</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">trans_csrrd</span><span class="p">(</span><span class="n">CPULoongArchState</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">arg_csrrd</span><span class="w"> </span><span class="o">*</span><span class="kr">restrict</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">CHECK_PLV</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">helper_read_csr</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">csr</span><span class="p">);</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">csr</span><span class="p">)</span>
<span class="w">    </span><span class="n">cpu_set_pc</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">pc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在模拟实现 CSRRD 指令时，函数首先调用<code class="docutils literal notranslate"><span class="pre">CHECK_PLV(0)</span></code>，检查运行环境是否满足特权级 PLV0 。然后，根据 csr_num 值，调用<code class="docutils literal notranslate"><span class="pre">helper_read_csr</span></code>函数，从指定 CSR 读取数值，并写回到对应目的寄存器中。程序执行到下一条指令。</p>
</div>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p><em><strong>在哪里会用到这条指令？</strong></em></p>
<p>CSRRD 指令，常见于操作系统判断应硬件的状态，一般读取状态类 CSR 。比如，读取 0x20 地址的 CSR ，可以获取 CPUID ，读取 0x5 ，可以获取 ESTAT 值，该值可以表示展示 CPU 的异常状态，提供信息，方便操作系统判断下一步处理。</p>
</div>
</section>
<section id="csrwr">
<h2><span class="section-number">3.2.2. </span>CSRWR指令<a class="headerlink" href="#csrwr" title="Link to this heading"></a></h2>
<p>格式: <code class="docutils literal notranslate"><span class="pre">csrwr</span> <span class="pre">	rd,csr_num</span></code></p>
<p>操作:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>temp &lt;- GPR[rd]
GPR[rd] &lt;- CSR[csr_num]
CSR[csr_num] &lt;- temp
</pre></div>
</div>
<p>CSRWR 指令将通用寄存器 rd 中的旧值，写入到指定 CSR 中，同时，将指定 CSR 的旧值，更新到通用寄存器 rd 中。</p>
<p>其中，csr_num 是 14 比特立即数，用来描述目标 CSR 的编号，其对应关系可查看 3.1 章节对应关系表格。</p>
<p>所有 CSR 寄存器的位宽可能是 32 位宽，或者与架构中的通用寄存器 GR 等宽，因此 CSR 指令不区分位宽。
在 LA32 架构下，所有 CSR 寄存器都是 32 位宽。在 LA64 架构下，定义中宽度固定为 32 位的 CSR ，需要符号扩展后写入到通用寄存器 rd 中。</p>
<p>当 CSRWR 指令访问一个架构中未定义或硬件未实现的 CSR 时，写操作不会修改通用寄存器和 CSR 的值。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在模拟器 LA_EMU 中可查看 CSRWR 指令的模拟实现。
在<code class="docutils literal notranslate"><span class="pre">LA_EMU/loongarch64/interpreter.c</span></code>中，可以查看如下函数实现:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">mask_write</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">old</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">new</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">old</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint64_t</span><span class="w"> </span><span class="nf">helper_write_csr</span><span class="p">(</span><span class="n">CPULoongArchState</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">csr_index</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">new_v</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">old_v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">csr_index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">LOONGARCH_CSR_CRMD</span><span class="w">           </span><span class="p">:</span><span class="n">old_v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">CSR_CRMD</span><span class="p">;</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">CSR_CRMD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mask_write</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">CSR_CRMD</span><span class="p">,</span><span class="w"> </span><span class="n">new_v</span><span class="p">,</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">LOONGARCH_CSR_CRMD_WMASK</span><span class="p">);</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">LOONGARCH_CSR_PRMD</span><span class="w">           </span><span class="p">:</span><span class="n">old_v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">CSR_PRMD</span><span class="p">;</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">CSR_PRMD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mask_write</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">CSR_PRMD</span><span class="p">,</span><span class="w"> </span><span class="n">new_v</span><span class="p">,</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">LOONGARCH_CSR_PRMD_WMASK</span><span class="p">);</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//	...</span>
<span class="w">        </span><span class="k">default</span><span class="o">:</span><span class="w">	</span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;NOT IMPLEMENTED %s %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">__func__</span><span class="p">,</span><span class="w"> </span><span class="n">csr_index</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">old_v</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">trans_csrwr</span><span class="p">(</span><span class="n">CPULoongArchState</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">arg_csrwr</span><span class="w"> </span><span class="o">*</span><span class="kr">restrict</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">CHECK_PLV</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">helper_write_csr</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">csr</span><span class="p">,</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">],</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span>
<span class="w">    </span><span class="n">cpu_set_pc</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">pc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在模拟实现 CSRWR 指令时，函数首先调用<code class="docutils literal notranslate"><span class="pre">CHECK_PLV(0)</span></code>，检查运行环境是否满足特权级 PLV0 。然后，根据 csr_num 值，调用<code class="docutils literal notranslate"><span class="pre">helper_write_csr</span></code>函数，将 rd 寄存器中数值写入指定 CSR ，并将 CSR 原值写回到 rd 寄存器中。程序执行到下一条指令。</p>
<p>此处<code class="docutils literal notranslate"><span class="pre">mask_write</span></code>作为掩码处理函数，掩码被设置为全 1 ，即保持 rd 寄存器原值不变。</p>
</div>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p><em><strong>为什么 CSRWR 指令，要将 CSR 的旧值，写回到寄存器 rd 中？在哪里会用到这条指令？</strong></em></p>
<p>CSRWR 指令，快捷实现了 CSR 值与寄存器 rd 值的交换。在操作系统进行用户进程与内核切换时，有时需要将用户栈寄存器 SP 的值到 CSR ，同时将 CSR 中保存的内核栈替换到寄存器 SP 中，可使用一条 CSRWR 指令，实现数值快速交换。</p>
</div>
</section>
<section id="csrxchg">
<h2><span class="section-number">3.2.3. </span>CSRXCHG指令<a class="headerlink" href="#csrxchg" title="Link to this heading"></a></h2>
<p>格式:	<code class="docutils literal notranslate"><span class="pre">csrxchg</span> <span class="pre">	rd,rj,csr_num</span></code></p>
<p>操作:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tmp = GPR[rd]
GPR[rd] = CSR[csr_num]
CSR[csr_num] = (tmp &amp; GPR[rj]) | (CSR[csr_num] &amp; ~GPR[rj])
</pre></div>
</div>
<p>CSRXCHG 指令根据通用寄存器 rj 中存放的写掩码信息，将通用寄存器 rd 中的旧值，写入到指定 CSR 中对应写掩码为 1 的那些比特，该 CSR 中的其余比特保持不变，同时，将指定 CSR 的旧值，更新到通用寄存器 rd 中。</p>
<p>其中，csr_num 是 14 比特立即数，用来描述指定 CSR 的编号，其对应关系可查看 3.1 章节对应关系表格。</p>
<p>所有 CSR 寄存器的位宽可能是 32 位宽，或者与架构中的通用寄存器 GR 等宽，因此 CSR 指令不区分位宽。
在 LA32 架构下，所有 CSR 寄存器都是 32 位宽。在 LA64 架构下，定义中宽度固定为 32 位的 CSR ，需要符号扩展后写入到通用寄存器 rd 中。</p>
<p>当 CSRXCHG 指令访问一个架构中未定义或硬件未实现的 CSR 时，写操作不会修改通用寄存器和 CSR 的值。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>在模拟器 LA_EMU 中可查看 CSRXCHG 指令的模拟实现。
在<code class="docutils literal notranslate"><span class="pre">LA_EMU/loongarch64/interpreter.c</span></code>中，可以查看如下函数实现:</p>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">mask_write</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">old</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">new</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">old</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint64_t</span><span class="w"> </span><span class="nf">helper_write_csr</span><span class="p">(</span><span class="n">CPULoongArchState</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">csr_index</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">new_v</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">old_v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">csr_index</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">LOONGARCH_CSR_CRMD</span><span class="w">           </span><span class="p">:</span><span class="n">old_v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">CSR_CRMD</span><span class="p">;</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">CSR_CRMD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mask_write</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">CSR_CRMD</span><span class="p">,</span><span class="w"> </span><span class="n">new_v</span><span class="p">,</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">LOONGARCH_CSR_CRMD_WMASK</span><span class="p">);</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="no">LOONGARCH_CSR_PRMD</span><span class="w">           </span><span class="p">:</span><span class="n">old_v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">CSR_PRMD</span><span class="p">;</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">CSR_PRMD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mask_write</span><span class="p">(</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">CSR_PRMD</span><span class="p">,</span><span class="w"> </span><span class="n">new_v</span><span class="p">,</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">LOONGARCH_CSR_PRMD_WMASK</span><span class="p">);</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//	...</span>
<span class="w">        </span><span class="k">default</span><span class="o">:</span><span class="w">	</span><span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;NOT IMPLEMENTED %s %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">__func__</span><span class="p">,</span><span class="w"> </span><span class="n">csr_index</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">old_v</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">trans_csrxchg</span><span class="p">(</span><span class="n">CPULoongArchState</span><span class="w"> </span><span class="o">*</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">arg_csrxchg</span><span class="w"> </span><span class="o">*</span><span class="kr">restrict</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">CHECK_PLV</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">helper_write_csr</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="o">-&gt;</span><span class="n">csr</span><span class="p">,</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">],</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">gpr</span><span class="p">[</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">rj</span><span class="p">]);</span>
<span class="w">    </span><span class="n">cpu_set_pc</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">env</span><span class="o">-&gt;</span><span class="n">pc</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在模拟实现 CSRXCHG 指令时，函数首先调用<code class="docutils literal notranslate"><span class="pre">CHECK_PLV(0)</span></code>，检查运行环境是否满足特权级 PLV0 。然后，调用<code class="docutils literal notranslate"><span class="pre">mask_write</span></code>掩码处理函数，将寄存器 rd 与 rj 值进行掩码处理，计算得到要写入值。其次，根据 csr_num 值，调用<code class="docutils literal notranslate"><span class="pre">helper_write_csr</span></code>函数，将写入值写入指定 CSR ，并将 CSR 原值写回到 rd 寄存器中。程序执行到下一条指令。</p>
<p>此处作为掩码处理函数，掩码由寄存器 rj 决定。</p>
</div>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p><em><strong>为什么 CSRXCHG 指令，要设置掩码写入？在哪里会用到这条指令？</strong></em></p>
<p>CSRXCHG 指令，快捷实现了 CSR 值的部分写入。</p>
<p>CSR 寻址最小单位为一个 CSR 值宽度，同时，CSR 值中可能每一位都有独特的状态与控制逻辑。</p>
<p>如果，操作系统只想改变某个硬件状态，同时不改变其他硬件状态，可以使用 CSRXCHG 指令实现。</p>
<p>例如，CSR.CRMD 包含多种硬件的状态信息，如果只想打开硬件中断使能，即使 CSR.CRMD[2] 位为 1 ，同时，其他位保持不变，可使用以下汇编指令:</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="w">	</span><span class="nf">li.d</span><span class="w"> 		</span><span class="no">t0</span><span class="p">,</span><span class="mi">0x4</span>
<span class="w">	</span><span class="nf">li.d</span><span class="w"> 		</span><span class="no">t1</span><span class="p">,</span><span class="mi">0x4</span>
<span class="w">	</span><span class="nf">csrxchg</span><span class="w"> 	</span><span class="no">t0</span><span class="p">,</span><span class="no">t1</span><span class="p">,</span><span class="mi">0x0</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="iocsr">
<h1><span class="section-number">3.3. </span>IOCSR指令<a class="headerlink" href="#iocsr" title="Link to this heading"></a></h1>
<p>除了描述 CPU 内部状态信息的一组 CSR 寄存器外，还有另外一组控制状态寄存器 IOCSR，用于描述 CPU 外部、系统总线上的设备配置与控制空间。</p>
<p>与 CSR 类似，IOCSR 也有独立的编号，对应也有独立的寻址空间。该地址空间与 CSR 空间、内存地址空间并行。但 IOCSR 的地址空间更大，采用直接映射方式，其物理地址等于逻辑地址。同时，寻址基本单位为字节，所有数据在 IOCSR 空间中采用小尾端存储格式。</p>
<p>与 CSR 访问对比，作为 CPU 总线访问，IOCSR 访问的速度要慢一个量级。</p>
<p>IOCSR 寄存器通常可以被多个处理器核同时访问。多个处理器核上 IOCSR 访问指令的执行满足顺序一致性条件。</p>
<p>与 CSR 类似，访问 IOCSR 需要特殊的指令，如 LoongArch 中的 IOCSR{RD/WR}.{B/H/W/D} ，这保证了只有拥有足够特权级（如操作系统内核）才能操作它们，是安全性的基石，本章详细介绍这些特权指令。</p>
<section id="iocsrrd">
<h2><span class="section-number">3.3.1. </span>IOCSRRD指令<a class="headerlink" href="#iocsrrd" title="Link to this heading"></a></h2>
<p>格式:	<code class="docutils literal notranslate"><span class="pre">iocsrrd.b</span> <span class="pre">rd,rj</span></code>
<code class="docutils literal notranslate"><span class="pre">iocsrrd.h</span> <span class="pre">rd,rj</span></code>
<code class="docutils literal notranslate"><span class="pre">iocsrrd.w</span> <span class="pre">rd,rj</span></code>
<code class="docutils literal notranslate"><span class="pre">iocsrrd.d</span> <span class="pre">rd,rj</span></code></p>
<p>操作:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>GPR[rd] = SignExtend(IOCSR[rj][ 7:0],GRLEN)
GPR[rd] = SignExtend(IOCSR[rj][15:0],GRLEN)
GPR[rd] = SignExtend(IOCSR[rj][31:0],GRLEN)
GPR[rd] = IOCSR[rj][63:0]
</pre></div>
</div>
<p>IOCSRRD.{B/H/W/D} 指令，以寄存器 rj 中数值为指定地址，从 IOCSR 空间处读取字节/半字/字/双字长度的数据，如位宽小于 GRLEN ,则进行符号扩展后，将结果写入到寄存器 rd 中。</p>
<p>IOCSRRD.D 和指令只出现在 LA64 架构中。</p>
</section>
<section id="iocsrwr">
<h2><span class="section-number">3.3.2. </span>IOCSRWR指令<a class="headerlink" href="#iocsrwr" title="Link to this heading"></a></h2>
<p>格式:	<code class="docutils literal notranslate"><span class="pre">iocsrwr.b</span> <span class="pre">rd,rj</span></code>
<code class="docutils literal notranslate"><span class="pre">iocsrwr.h</span> <span class="pre">rd,rj</span></code>
<code class="docutils literal notranslate"><span class="pre">iocsrwr.w</span> <span class="pre">rd,rj</span></code>
<code class="docutils literal notranslate"><span class="pre">iocsrwr.d</span> <span class="pre">rd,rj</span></code></p>
<p>操作:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>IOCSR[rj][ 7:0] = GPR[rd][ 7:0]
IOCSR[rj][15:0] = GPR[rd][15:0]
IOCSR[rj][31:0] = GPR[rd][31:0]
IOCSR[rj][63:0] = GPR[rd][63:0]
</pre></div>
</div>
<p>IOCSRWR.{B/H/W/D} 指令将寄存器 rd 中的 [7:0]/[15:0]/[31:0]/[63:0] 位数据，以寄存器 rj 中数值为指定地址，写入到 IOCSR 空间处。</p>
<p>IOCSRWR.D 指令只出现在 LA64 架构中。</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p><em><strong>在哪里会用到这组指令？</strong></em></p>
<p>IOCSRWR 指令，可以替代原有的地址映射配置寄存器的方式，实现了操作系统对 CPU 外设的管理和控制。这样访问配置可以不经过硬件的 Load/Store 处理单元，缓解硬件流水线压力，同时保证了指令的原子性。</p>
<p>例如，在 3A5000 芯片中，想要读取 CORE0 扩展 IO 中断状态(如查询串口、键盘等外设的中断是否有使能)，可通过 访问 IOCSR 空间内 0x1800 地址(可查询 3A5000 芯片寄存器手册)，进行查询。</p>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
    <a href="index.html" class="btn btn-neutral float-left" title="3. 特权态指令" accesskey="p"
      rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    <a href="cacop_insn.html" class="btn btn-neutral float-right" title="3.4. CPUCFG 指令" accesskey="n"
      rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>

  <hr />

  <div role="contentinfo">
    <p>&#169; 版权所有 2022-2026, 龙芯中科技术有限公司。
      <span class="lastupdated">最后更新于 2026年2月10日 11:15:08.
      </span>

      <!-- 
      <span class="footer-aside">
        <a href="../../龙芯实验室文档.pdf" class="fa fa-file-pdf-o">&nbsp下载 PDF</a>
      </span>
       -->
    </p>
  </div> 

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>