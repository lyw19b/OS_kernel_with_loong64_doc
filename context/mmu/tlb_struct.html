<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>4.1. LoongArch的地址管理 &mdash; 龙芯实验室文档 V1.0 文档</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=b01b2dd9" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />

  
    <link rel="shortcut icon" href="../../_static/favicon.jpg"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=3f0bcac8"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=f281be69"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
        <script src="../../_static/translations.js?v=beaddf03"></script>
        <script src="../../_static/design-tabs.js?v=f930bc37"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="4.4. 直接映射翻译模式" href="dmw.html" />
    <link rel="prev" title="4. 内存管理" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <img src="../../_static/logo.svg" class="logo" alt="Logo"/>
          <a href="../../index.html" class="icon icon-home">
            龙芯实验室文档
          </a>
              <div class="version">
                V1.0
              </div>
<div role="search">
  <form id="evas-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../preparation/index.html">1. 准备工作</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../preparation/preface.html">1.1. 前言</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../preparation/preface.html#id2">1.1.1. 更新说明</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/preface.html#id3">1.1.2. 仓库地址</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../preparation/tools.html">1.2. 工具链说明</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#gcc">1.2.1. GCC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#llvm">1.2.2. LLVM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#rust">1.2.3. Rust</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../preparation/tools.html#id2">1.3. 模拟器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#qemu">1.3.1. QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#la-emu">1.3.2. LA_EMU</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../preparation/tools.html#id3">1.4. 操作系统编译</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#loongnix">1.4.1. LoongNix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#uos">1.4.2. UOS</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#deepin">1.4.3. Deepin</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#aosc">1.4.4. AOSC(安同)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#linux-kernel">1.4.5. Linux kernel</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../toolchains/index.html">2. 工具链</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/gcc.html">2.1. GCC</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/gcc.html#id1">2.1.1. GCC的相关概念</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id2">2.1.1.1. GCC的基本定义与起源</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id4">2.1.1.2. GCC支持的语言与平台</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id5">2.1.1.3. GCC的核心功能与特点</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id6">2.1.1.4. GCC的最新进展</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id7">2.1.1.5. GCC的应用场景</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/gcc.html#id8">2.1.2. 交叉编译器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/gcc.html#id9">2.1.3. 常见的类别组合</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/gcc.html#id12">2.1.4. 如何编译交叉编译器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#loongarch64-linux-gnu-sf">2.1.4.1. 如何编译loongarch64-linux-gnu[sf]</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#loongarch64-linux-musl-sf">2.1.4.2. 如何编译loongarch64-linux-musl[sf]</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#crtn-crti-crtbegin-crtend">2.1.4.3. crtn, crti, crtbegin, crtend有什么区别</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/gcc.html#id22">2.1.5. 常用的参数与选项</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id23">2.1.5.1. GCC常见的参数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#picpie">2.1.5.2. PIC与PIE的区别是什么</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#loongarch">2.1.5.3. 与LoongArch相关的选项说明</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#c-c">2.1.5.4. C/C++ 预处理器内嵌的宏定义</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/binutils.html">2.2. Binutils</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/binutils.html#gnu-binutils">2.2.1. GNU Binutils的相关说明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id1">2.2.1.1. <strong>核心定位与背景</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id2">2.2.1.2. <strong>重要组成部分与功能</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id5">2.2.1.3. <strong>应用场景</strong></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/binutils.html#ld">2.2.2. ld链接器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id6">2.2.2.1. LD的参数说明</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/binutils.html#readelf">2.2.3. 如何正确的使用readelf</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id7">2.2.3.1. 基础用法与核心选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id11">2.2.3.2. 二、高级用法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id14">2.2.3.3. 三、实战示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id18">2.2.3.4. 四、与其他工具对比</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/binutils.html#objdump">2.2.4. objdump</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id19">2.2.4.1. 一、基础用法与核心选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id25">2.2.4.2. 二、高级用法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id31">2.2.4.3. 三、典型应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id36">2.2.4.4. 四、与其他工具对比</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id37">2.2.4.5. 五、注意事项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id38">2.2.4.6. 六、实战示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/binutils.html#objcopy">2.2.5. objcopy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id42">2.2.5.1. 一、基础用法与核心选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id46">2.2.5.2. 二、高级功能</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id51">2.2.5.3. 三、参数详解</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id52">2.2.5.4. 四、典型应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id56">2.2.5.5. 五、常见问题与解决</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id60">2.2.5.6. 六、与其他工具对比</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id61">2.2.5.7. 七、总结</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/rust.html">2.3. Rust</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/rust.html#id1">2.3.1. Rust的概念</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/rust.html#id2">2.3.1.1. Rust的起源与发展</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/rust.html#id3">2.3.1.2. Rust的核心特性</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/rust.html#id4">2.3.1.3. Rust的应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/rust.html#id5">2.3.1.4. Rust的最新进展</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/rust.html#id6">2.3.1.5. Rust的优缺点</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/rust.html#loongarchtarget">2.3.2. LoongArch支持的target有哪些</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/rust.html#loongarch">2.3.3. 与LoongArch相关的具体参数那些</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/rust.html#laexe">2.3.4. 简单的例子说明如何编译成LA架构的EXE文件</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/builtin.html">2.4. 内嵌的函数与指令包装</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/builtin.html#gcc">2.4.1. GCC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/builtin.html#llvm">2.4.2. LLVM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/builtin.html#rust">2.4.3. Rust</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/builtin.html#loongarch">2.4.3.1. LoongArch包的相关内容</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/assembly.html">2.5. 汇编代码与链接脚本</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/assembly.html#loongarch">2.5.1. 与LoongArch相关的汇编指令</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id2">2.5.1.1. 伪汇编指令</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id3">2.5.1.2. 地址加载指令</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id4">2.5.1.3. 内嵌汇编</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id5">2.5.1.4. 参考阅读</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/assembly.html#id6">2.5.2. 链接脚本</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id7">2.5.2.1. 一、基础语法结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id8">2.5.2.2. 二、核心命令与操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id13">2.5.2.3. 三、高级功能</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id17">2.5.2.4. 四、典型应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id21">2.5.2.5. 五、实战示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id24">2.5.2.6. 六、调试与验证</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id25">2.5.2.7. 七、总结</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id26">2.5.2.8. 以LoongArch为例说明链接脚本</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/library.html">2.6. 一些常用的库函数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/library.html#glibc">2.6.1. GLIBC</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id2">2.6.1.1. 一、核心功能与作用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id3">2.6.1.2. 二、架构与实现细节</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id4">2.6.1.3. 三、版本演进与升级风险</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id5">2.6.1.4. 四、与其他运行库的对比</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id6">2.6.1.5. 五、开发与调试工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/library.html#musl">2.6.2. MUSL</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#musl-c">2.6.2.1. Musl C 库详解</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id15">2.6.2.2. 总结</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/library.html#memcpy">2.6.3. memcpy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/library.html#memmove">2.6.4. memmove</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/library.html#memset">2.6.5. memset</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../privilege_isa/index.html">3. 特权态指令</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/csr.html">3.1. CSR寄存器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/csr.html#id1">3.2. CSR指令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../privilege_isa/csr.html#csrrd">3.2.1. CSRRD指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../privilege_isa/csr.html#csrwr">3.2.2. CSRWR指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../privilege_isa/csr.html#csrxchg">3.2.3. CSRXCHG指令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/csr.html#iocsr">3.3. IOCSR指令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../privilege_isa/csr.html#iocsrrd">3.3.1. IOCSRRD指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../privilege_isa/csr.html#iocsrwr">3.3.2. IOCSRWR指令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/cacop_insn.html">3.4. CPUCFG 指令</a></li>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/cacop_insn.html#cacop">3.5. CACOP 指令</a></li>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/tlb_insn.html">3.6. TLB 与页表指令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../privilege_isa/tlb_insn.html#id1">3.6.1. TLB 相关指令</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#tlbsrch">3.6.1.1. TLBSRCH</a></li>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#tlbrd">3.6.1.2. TLBRD</a></li>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#tlbwr">3.6.1.3. TLBWR</a></li>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#tlbfill">3.6.1.4. TLBFILL</a></li>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#tlbclr">3.6.1.5. TLBCLR</a></li>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#tlbflush">3.6.1.6. TLBFLUSH</a></li>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#invtlb">3.6.1.7. INVTLB</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../privilege_isa/tlb_insn.html#id2">3.6.2. 页表查找指令</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#lddir">3.6.2.1. LDDIR</a></li>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#ldpte">3.6.2.2. LDPTE</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../privilege_isa/tlb_insn.html#id3">3.6.3. 应用示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/misc_insn.html">3.7. ERTN指令</a></li>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/misc_insn.html#idle">3.8. IDLE指令</a></li>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/misc_insn.html#syscall">3.9. SysCALL指令</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">4. 内存管理</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">4.1. LoongArch的地址管理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">4.1.1. 直接地址翻译模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">4.1.2. 映射地址翻译模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">4.1.3. 存储访问的类型</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#loongarchtlb">4.2. LoongArch的TLB结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">4.2.1. 逻辑组织结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tlb-cpu">4.2.2. TLB的表项（以CPU的视觉）</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tlb">4.3. TLB的管理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">4.3.1. TLB的一些概念区分</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">4.3.2. TLB相关的指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tlbcsr">4.3.3. TLB相关的CSR</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tlb-excption-handle">4.3.4. TLB相关的例外</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cputlb">4.3.5. CPU内部TLB查找流程示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="dmw.html">4.4. 直接映射翻译模式</a><ul>
<li class="toctree-l3"><a class="reference internal" href="dmw.html#csr-dmw-0-3">4.4.1. CSR.DMW[0-3]</a></li>
<li class="toctree-l3"><a class="reference internal" href="dmw.html#id2">4.4.2. 操作系统中如何使用</a><ul>
<li class="toctree-l4"><a class="reference internal" href="dmw.html#dmw">4.4.2.1. DMW的优点</a></li>
<li class="toctree-l4"><a class="reference internal" href="dmw.html#id3">4.4.2.2. DMW的缺点</a></li>
<li class="toctree-l4"><a class="reference internal" href="dmw.html#id4">4.4.2.3. 代码示例如何在内核中使用</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tlb_ptw.html">4.5. 多级页表结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tlb_ptw.html#id2">4.5.1. 设计背景与必要性</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id3">4.5.1.1. 多级页表的结构与层级</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id4">4.5.1.2. 地址转换流程</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id5">4.5.1.3. 多级页表的优势</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id6">4.5.1.4. 优化机制</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id7">4.5.1.5. 对比不同架构的页表设计</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="tlb_ptw.html#loongarch">4.5.2. LoongArch的多级页表结构</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#kernel">4.5.2.1. Kernel如何初始化设置多级页表结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#kb">4.5.2.2. 二级页表，4KB页大小</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id8">4.5.2.3. 二级页表，16KB页大小</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id9">4.5.2.4. 三级页表，4KB页大小</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id10">4.5.2.5. 三级页表，16KB页大小</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id11">4.5.2.6. 四级页表，4KB页大小</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id12">4.5.2.7. 四级页表，16KB页大小</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="tlb_ptw.html#id13">4.5.3. 内存中的页表表项（Kernel视角）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id14">4.5.3.1. 基本页表（叶子节点）</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id15">4.5.3.2. 大页页表（叶子节点）</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#no-leaf-pg-entry">4.5.3.3. 中间指向下一级目录的地址的页表(非叶子节点页表)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="tlb_ptw.html#id17">4.5.4. 页表的遍历</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#k">4.5.4.1. 以一个例子4K页为例说明：</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#m">4.5.4.2. 以一个例子2M页为例说明：</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tlb_ptw.html#cputlb">4.6. 从内存中的页表表项到CPU中的TLB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tlb_ptw.html#tlbrefill-softeware-ptw">4.6.1. TLBRefill (Softeware PTW)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#csr">4.6.1.1. 相关的CSR寄存器</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id18">4.6.1.2. 重填示例代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id19">4.6.1.3. 两级页表的示例代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#three-level-page-table-refill">4.6.1.4. 三级页表的示例代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id21">4.6.1.5. 四级页表的示例代码</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="tlb_ptw.html#hardware-ptw">4.6.2. Hardware PTW</a></li>
<li class="toctree-l3"><a class="reference internal" href="tlb_ptw.html#id22">4.6.3. 页表的刷新</a><ul>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id23">4.6.3.1. 页表为什么需要刷新</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id24">4.6.3.2. 页表刷新的指令</a></li>
<li class="toctree-l4"><a class="reference internal" href="tlb_ptw.html#id25">4.6.3.3. 页表刷新的例子</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="page_table_in_kernel.html">4.7. Kernel与MMU</a><ul>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#id1">4.7.1. 地址翻译相关的初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#id2">4.7.2. 如何从直接地址翻译模式到映射地址翻译模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#id3">4.7.3. 如何建立虚拟地址到物理地址的映射关系</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#id4">4.7.4. 页表的遍历页表</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#tlb">4.7.5. 情况1. 如果TLB中没有映射</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#v-0">4.7.6. 情况2. 如果页表项的V=0</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#d-0">4.7.7. 情况3. 如果写操作页表项D=0</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#id5">4.7.8. 情况4. 如果权限不合法</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#ptw">4.7.9. 如果使能硬件PTW</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../trap/index.html">5. 中断与异常系统</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../trap/interrupt.html">5.1. 中断</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id2">5.1.1. 线中断</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#ipi">5.1.1.1. 核间中断IPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id3">5.1.1.2. 定时器中断</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id4">5.1.1.3. 性能计数器中断</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id5">5.1.1.4. 外部硬中断</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id6">5.1.1.5. 内部软中断</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id7">5.1.1.6. 中断号</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id8">5.1.2. 消息中断</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id9">5.1.3. 中断的优先级</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id10">5.1.3.1. 线中断的优先级</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id11">5.1.3.2. 消息中断的优先级</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id12">5.1.4. 中断的打开与关闭</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id13">5.1.5. 中断的入口地址</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id14">5.1.6. 中断的处理流程</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../trap/exception.html">5.2. 例外</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../trap/exception.html#id2">5.2.1. 例外的优先级</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/exception.html#id3">5.2.2. 例外的入口地址</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/exception.html#id4">5.2.3. 例外的处理过程</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../trap/exception.html#id5">5.2.3.1. 普通例外的处理过程</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/exception.html#tlb">5.2.3.2. TLB 重填例外硬件处理过程</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/exception.html#id6">5.2.3.3. 机器错误例外硬件处理过程</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../trap/trap_in_kernel.html">5.3. Kernel与异常</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#expection-entry-selection">5.3.1. 异常的入口地址选择</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../trap/trap_in_kernel.html#id2">5.3.1.1. “统一式”的入口地址</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/trap_in_kernel.html#id3">5.3.1.2. “分离式”的入口地址</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#id4">5.3.2. 异常的初始化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../trap/trap_in_kernel.html#id5">5.3.2.1. 统一式的初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/trap_in_kernel.html#id7">5.3.2.2. 分离式的初始化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#cpu">5.3.3. 异常发生时，CPU做了什么</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../trap/trap_in_kernel.html#id9">5.4. 特殊异常的处理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#id10">5.4.1. 定时器中断</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#id11">5.4.2. 系统调用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#id12">5.4.3. 非对齐访问</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../smp/index.html">6. SMP多核系统</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../smp/smp.html">6.1. SMP与LoongArch</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../smp/smp.html#ipi">6.1.1. IPI中断</a></li>
<li class="toctree-l3"><a class="reference internal" href="../smp/smp.html#id1">6.1.2. 如何通信</a></li>
<li class="toctree-l3"><a class="reference internal" href="../smp/smp.html#id2">6.1.3. 如何初始化</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../smp/smp.html#linuxsmp">6.2. Linux中SMP的处理（与架构相关）</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../abi/index.html">7. 程序二进制接口</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../abi/new_and_old_world.html">7.1. 新旧世界</a></li>
<li class="toctree-l2"><a class="reference internal" href="../abi/new_and_old_world.html#id2">7.2. 旧世界</a></li>
<li class="toctree-l2"><a class="reference internal" href="../abi/new_and_old_world.html#id3">7.3. 新世界</a></li>
<li class="toctree-l2"><a class="reference internal" href="../abi/new_and_old_world.html#id4">7.4. 新旧世界的区分</a></li>
<li class="toctree-l2"><a class="reference internal" href="../abi/abi.html">7.5. ABI 2.0</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../debug/index.html">8. 调试方法与技巧</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../debug/debug_env.html">8.1. LoongArch最小debug环境搭建</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_env.html#linux-ramdisk">8.1.1. 制作Linux RamDisk</a></li>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_env.html#qemu">8.1.2. 如何在 QEMU 中调试</a></li>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_env.html#id1">8.1.3. 设置断点</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../debug/debug_gdb.html">8.2. GDB的使用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_gdb.html#id1">8.2.1. 交叉编译环境中的GDB</a></li>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_gdb.html#id2">8.2.2. 常见的GDB命令示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_gdb.html#id3">8.2.3. 调试指令常见失效状况</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../platform/index.html">9. 平台相关</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../platform/qemu.html">9.1. QEMU</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/qemu.html#virt">9.1.1. Virt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/qemu.html#id1">9.1.2. 设备</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/3a5000.html">9.2. 3A5000芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/3a5000.html#id1">9.2.1. 芯片参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/3a5000.html#id2">9.2.2. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/3a5000.html#id3">9.2.3. 地址空间</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../platform/3a5000.html#id4">9.2.3.1. 结点间物理地址空间</a></li>
<li class="toctree-l4"><a class="reference internal" href="../platform/3a5000.html#id5">9.2.3.2. 结点内物理地址空间</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/3a6000.html">9.3. 3A6000芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/3a6000.html#id1">9.3.1. 芯片参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/3a6000.html#id2">9.3.2. 芯片架构</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/2k3000.html">9.4. 2k3000芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k3000.html#id1">9.4.1. 芯片参数</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/2k1000la.html">9.5. 2k1000LA芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k1000la.html#id1">9.5.1. 芯片参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k1000la.html#id2">9.5.2. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k1000la.html#id3">9.5.3. 芯片功能</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k1000la.html#id4">9.5.4. 地址空间</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/2k0500.html">9.6. 2k0500芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id1">9.6.1. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id2">9.6.2. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id3">9.6.3. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id4">9.6.4. 芯片功能</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id5">9.6.5. 地址空间</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id6">9.6.6. 中断配置</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/2k0300.html">9.7. 2k0300芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0300.html#id1">9.7.1. 芯片参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0300.html#id2">9.7.2. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0300.html#id3">9.7.3. 芯片功能</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0300.html#id4">9.7.4. 地址空间</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0300.html#id5">9.7.5. 中断配置及路由</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../simd/index.html">10. 高级应用：SMID与向量指令</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../simd/todo.html">10.1. TODO</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">11. 高级应用：LVZ与虚拟化扩展</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../virt/todo.html">11.1. TODO</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">12. FAQ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../faq/faq-25.html">12.1. FAQ-25</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">龙芯实验室文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html"><span class="section-number">4. </span>内存管理</a></li>
      <li class="breadcrumb-item active"><span class="section-number">4.1. </span>LoongArch的地址管理</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="loongarch">
<h1><span class="section-number">4.1. </span>LoongArch的地址管理<a class="headerlink" href="#loongarch" title="Link to this heading"></a></h1>
<p>龙芯架构中虚拟地址空间是线性平整的。在LoongArch64架构下，2<sup>64</sup>字节的空间<strong>并不都是合法的</strong>，下面实际说明：</p>
<ol class="arabic simple">
<li><p><strong>物理地址空间</strong></p></li>
</ol>
<p>在LoongArch64下，内存的物理地址范围[0, 2<sup>PALEN</sup>-1]</p>
<p>其中，可以使用指令cpucfg读取配置字0x1的PALEN域来确定具体的值</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">li.w</span><span class="w">     </span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="mi">0x1</span>
<span class="nf">cpucfg</span><span class="w">   </span><span class="no">$t1</span><span class="p">,</span><span class="w"> </span><span class="no">$t0</span><span class="w">  </span><span class="c1"># $t1保存读取的配置字， $t1[11:4]的值是：所支持的物理地址位数的值减1</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p><strong>虚拟地址空间</strong></p></li>
</ol>
<ul>
<li><p>当CPU复位的时候，也就是CSR.CRMD<a class="footnote-reference brackets" href="#csr-note-explain" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>的 <code class="docutils literal notranslate"><span class="pre">DA=1</span> <span class="pre">&amp;&amp;</span> <span class="pre">PG=0</span></code><br />
此时，物理地址默认等于 <code class="docutils literal notranslate"><span class="pre">PA[PALEN-1:0]</span> <span class="pre">=</span> <span class="pre">VA[PALEN-1:0]</span></code><br />
(PA: Physical Address, 物理地址)，(VA: Virtual Address，虚拟地址)</p></li>
<li><p>当CPU使能映射地址模式: 也就是CSR.CRMD的<code class="docutils literal notranslate"><span class="pre">DA=0</span> <span class="pre">&amp;&amp;</span> <span class="pre">PG=1</span></code>时，<br />
VA虚拟地址有效宽度是VALEN，此时可以通过<code class="docutils literal notranslate"><span class="pre">cpucfg</span></code>指令读取配置字0x1的[19:12]位，表示所支持的虚拟地址位数减1</p>
<p>当采用页表映射时，虚拟地址最高位必须满足VA[63:VALEN] = SigExt(VA[VALEN-1])，即符号位扩展。如果不满足则生成地址错误异常。</p>
<p>比如：我现在CPU最大支持的虚拟地址是48位，则VALEN=48。
如果VA[63:48] =/= {17{VA[47]}}，则会报错！</p>
<p>注意在CPU复位的时候，是不需要进行这种非法性检查。</p>
</li>
</ul>
<section id="id2">
<h2><span class="section-number">4.1.1. </span>直接地址翻译模式<a class="headerlink" href="#id2" title="Link to this heading"></a></h2>
<p>LoongArch的直接映射地址翻译模式是一个比较特殊的映射模式，相比于其他的架构X86，ARM，RISC-V等。它是将一个很大的虚拟地址空间
线性的映射到了一个同等大小的物理空间（这里并没有要求这个物理地址空间都存在）。</p>
<p>当CSR.CRMD的<code class="docutils literal notranslate"><span class="pre">DA=0</span> <span class="pre">&amp;&amp;</span> <span class="pre">PG=1</span></code>时， 如果再配置了CSR.DMW0-CSR.DMW3寄存器，则可以使用此模式翻译。</p>
<p>也就是说，CPU复位以后，我们必须手动的设置CRMD，才能使用此模式的寄存器。复位情况下，是不能使用的。</p>
<p>具体的使用方法与说明我们详细看<a class="reference internal" href="dmw.html#csr-dmw"><span class="std std-ref">DMW章节</span></a></p>
</section>
<section id="id3">
<h2><span class="section-number">4.1.2. </span>映射地址翻译模式<a class="headerlink" href="#id3" title="Link to this heading"></a></h2>
<p>在映射地址翻译的模式下，除了上述说明的<strong>直接地址翻译模式</strong>外，就是我们经常所说的页式管理机制，将内存划分为页大小的块，
然后通过TLB转换获得虚拟地址到物理地址的转换。然后才能实际访问对应物理地址的内存。</p>
</section>
<section id="id4">
<h2><span class="section-number">4.1.3. </span>存储访问的类型<a class="headerlink" href="#id4" title="Link to this heading"></a></h2>
<p>LoongArch支持三种存储访问类型：</p>
<ul class="simple">
<li><p>一致性可缓存： Coherent Cached，主要是用于我们正常的内存访问</p></li>
<li><p>强序非缓存：Strong-ordered UnCached，主要是用于一些设备空间</p></li>
<li><p>弱序非缓存：Weakly-ordered UnCached，不常用</p></li>
</ul>
<p>下面我们简称 CSR.CRMD的<code class="docutils literal notranslate"><span class="pre">DA=1</span> <span class="pre">&amp;&amp;</span> <span class="pre">PG=0</span></code>时 为关闭MMU， CSR.CRMD的<code class="docutils literal notranslate"><span class="pre">DA=0</span> <span class="pre">&amp;&amp;</span> <span class="pre">PG=1</span></code>时 为打开MMU，</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>当<strong>CPU复位的</strong>时候，此时CSR.CRMD的<code class="docutils literal notranslate"><span class="pre">DA=1</span> <span class="pre">&amp;&amp;</span> <span class="pre">PG=0</span></code>时, CSR.CRMD寄存器管理</p>
<ul class="simple">
<li><p>取指令的访问类型：由CSR.CRMD.DATF决定</p></li>
<li><p>当其他load/store指令时的访问类型：由CSR.CRMD.DATM决定</p></li>
</ul>
</li>
</ol>
</div></blockquote>
<blockquote>
<div><ol class="arabic simple" start="2">
<li><p>当<strong>打开MMU时</strong>，即<code class="docutils literal notranslate"><span class="pre">DA=0</span> <span class="pre">&amp;&amp;</span> <span class="pre">PG=1</span></code>，</p>
<ul class="simple">
<li><p>此时如果地址落在了DMW内，则此时的访问类型由命中的DWMX.MAT域来决定。</p></li>
<li><p>如果地址落在了页表管理的页内，则此时由页表表项的[5:4]也就是MAT来管理。</p></li>
</ul>
</li>
</ol>
</div></blockquote>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>如果我们设置了一个地址A，然后这个地址既落在了DMW内，也有相应的页表映射，此时我们以DMW为主。<br />
也就是说CPU首先访问DMW，返回如果命中的话，就不会再去查找TLB了。</p>
</div>
<div class="admonition error">
<p class="admonition-title">错误</p>
<p>CSR.CRMD的DA和PG的可能组合是<code class="docutils literal notranslate"><span class="pre">DA=1</span> <span class="pre">&amp;&amp;</span> <span class="pre">PG=0</span></code> 或者<code class="docutils literal notranslate"><span class="pre">DA=0</span> <span class="pre">&amp;&amp;</span> <span class="pre">PG=1</span></code>，<br />
其他的组合情况，处理器的行为不确定，因此需要特殊注意！</p>
</div>
<!-- 1. 直接虚拟地址对应与物理地址
2. 初始化内核空间用DMW管理
3. 对于用户的空间，使用页表管理，禁止使用DMW
4. 内核空间的选择
   - 选择DMW的好处
   - 选择页表管理的好处
 -->
</section>
</section>
<section id="loongarchtlb">
<h1><span class="section-number">4.2. </span>LoongArch的TLB结构<a class="headerlink" href="#loongarchtlb" title="Link to this heading"></a></h1>
<p>本章节我们来介绍龙架构下的TLB的结构。</p>
<section id="id5">
<h2><span class="section-number">4.2.1. </span>逻辑组织结构<a class="headerlink" href="#id5" title="Link to this heading"></a></h2>
<p>LoongArch的TLB主要份两部分组成，一个是STLB，另一个是MTLB。下面详细介绍：</p>
<ol class="arabic">
<li><p>STLB（singular-Page-Size TLB）：从名字就可以看出其功能，</p>
<p>STLB中的表项的页大小都是固定的，其大小可以通过CSR.STLBPS来设置。</p>
</li>
<li><p>MTLB (Multiple-Page-Size TLB): 存放的是页大小不一致的页表映射。</p></li>
</ol>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p><strong>STLB</strong>由于其只保存相同页大小的页表项，因此采用多路组相连的组织方式，一般容量比较大。比如2048项，分成8个组等。</p>
<blockquote>
<div><blockquote>
<div><p>硬件查询STLB的时候，假设有组的个数为WAY，每组的大小为SET，索引为INDEX，PAGE_SIZE为页大小，他们的关系如下：</p>
</div></blockquote>
</div></blockquote>
<blockquote>
<div><blockquote>
<div><p>STLB大小 = WAY * SET，SET = 2{sup}INDEX PAGE_SIZE = 2{sup}PS</p>
</div></blockquote>
</div></blockquote>
<blockquote>
<div><blockquote>
<div><p>索引index的计算方法： INDEX=VA[PS+LOG2(SET): PS+1]</p>
</div></blockquote>
</div></blockquote>
<p><strong>MTLB</strong>保存多个页大小的表项，通常采用全相连的组织方式。全相连一般查询延迟比较大，因此容量比较小，通常为32或者64项等。</p>
</div>
</section>
<section id="tlb-cpu">
<h2><span class="section-number">4.2.2. </span>TLB的表项（以CPU的视觉）<a class="headerlink" href="#tlb-cpu" title="Link to this heading"></a></h2>
<p>硬件自动管理，无需过多的操作。</p>
<!-- ![这是图片](../../img/tlb_struct.png "TLB Struct") -->
<p>每一个 TLB 表项的格式如图所示，包含两个部分：<strong>比较部分</strong>和<strong>物理转换部分</strong>。</p>
<a class="bg-primary reference internal image-reference" href="../../_images/tlb_struct.png"><img alt="TLB Struct" class="bg-primary align-center" src="../../_images/tlb_struct.png" style="width: 922.5px; height: 207.5px;" /></a>
<!-- center, left, right -->
<p>TLB 表项的<strong>比较部分</strong>包括：</p>
<ul class="simple">
<li><p>❖存在位(E)，1 比特。为 1 表示所在 TLB 表项非空，可以参与查找匹配。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖地址空间标识(ASID)，10 比特。地址空间标识用于区分不同进程中的同样的虚地址，避免进程切<br />
换时清空整个 TLB 所带来的性能损失。操作系统为每个进程分配唯一的 ASID，TLB 在进行查找<br />
时除了比对地址信息一致外，还需要比对 ASID 信息。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖全局标志位(G)，1 比特。当该位为 1 时，查找时不进行 ASID 是否一致性的检查。当操作系统需要<br />
在所有进程间共享同一虚拟地址时，可以设置 TLB 页表项中的 G 位置为 1。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖页大小(PS)，6 比特。仅在 MTLB 中出现。用于指定该页表项中存放的页大小。数值是页大小的 2<br />
的幂指数。即对于 16KB 大小的页，PS=14。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖虚双页号(VPPN)，(VALEN-13)比特。在龙芯架构中，每一个页表项存放了相邻的一对奇偶相邻页<br />
表信息，所以 TLB 页表项中存放虚页号的是系统中虚页号/2 的内容，即虚页号的最低位不需要存<br />
放在 TLB 中。查找 TLB 时在根据被查找虚页号的最低位决定是选择奇数号页还是偶数号页的物理<br />
转换信息。</p></li>
</ul>
<hr class="docutils" />
<p>表项的<strong>物理转换部分</strong>存有一对奇偶相邻页表的物理转换信息，每一个页的转换信息包括：</p>
<ul class="simple">
<li><p>❖有效位(V)，1 比特。为 1 表明该页表项是有效的且被访问过的。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖脏位(D)，1 比特。为 1 表示该页表项项所对应的地址范围内已有脏数据。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖不可读位(NR)，1 比特。为 1 表示该页表项所在地址空间上不允许执行 load 操作。该控制位仅定<br />
义在 LA64 架构下。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖不可执行位(NX)，1 比特。为 1 表示该页表项所在地址空间上不允许执行取指操作。该控制位仅定<br />
义在 LA64 架构下。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖存储访问类型(MAT)，2 比特。控制落在该页表项所在地址空间上访存操作的存储访问类型。各数
值具体含义见 5.3 节。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖特权等级（PLV），2 比特。该页表项对应的特权等级。当 RPLV=0 时，该页表项可以被任何特权<br />
等级不低于 PLV 的程序访问；当 RPLV=1 时，该页表项仅可以被特权等级等于 PLV 的程序访问。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖受限特权等级使能（RPLV），1 比特。页表项是否仅被对应特权等级的程序访问的控制位。请参<br />
看上面 PLV 中的内容。该控制位仅定义在 LA64 架构下。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖物理页号(PPN)，(PALEN-12)比特。当页大小大于 4KB 的时候，TLB 中所存放的 PPN 的[PS-1:12]
位可以是任意值。</p></li>
</ul>
</section>
</section>
<section id="tlb">
<h1><span class="section-number">4.3. </span>TLB的管理<a class="headerlink" href="#tlb" title="Link to this heading"></a></h1>
<section id="id6">
<h2><span class="section-number">4.3.1. </span>TLB的一些概念区分<a class="headerlink" href="#id6" title="Link to this heading"></a></h2>
<p>主要是，什么是tlb重填(tlbrefill)，我们现在那些支持这项功能，
怎么动态的区分（使用cpucfg指令）。</p>
<p>什么是ptw，为什么存在硬件hptw，现在的那些平台支持hptw</p>
<p>TLB和地址转换是什么关系?</p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>龙芯架构没有规定必须实现 TLB 的硬件初始化，让启动阶段的软件通过执行</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">invtlb</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="no">$zero</span><span class="p">,</span><span class="w"> </span><span class="no">$zero</span>
</pre></div>
</div>
<p>来完成这一功能。</p>
</div>
</section>
<section id="id7">
<h2><span class="section-number">4.3.2. </span>TLB相关的指令<a class="headerlink" href="#id7" title="Link to this heading"></a></h2>
<p>TLB 相关的指令主要涉及对 TLB 的查找、读、写、无效等操作，用于进行 TLB 的填充、更新与一致性<br />
维护。具体的指令定义请参看本手册 4.2.4 节和 4.2.5 节中的内容。</p>
<ul class="simple">
<li><p>TLBSRCH</p></li>
<li><p>TLBRD</p></li>
<li><p>TLBWR</p></li>
<li><p>TLBFILL</p></li>
<li><p>TLBCLR</p></li>
<li><p>TLBFLUSH</p></li>
<li><p>INVTLB</p></li>
<li><p>LDDIR</p></li>
<li><p>LDPTE</p></li>
</ul>
</section>
<section id="tlbcsr">
<h2><span class="section-number">4.3.3. </span>TLB相关的CSR<a class="headerlink" href="#tlbcsr" title="Link to this heading"></a></h2>
<p>TLB 相关的 CSR 按照功能主要分为三类，</p>
<ol class="arabic simple">
<li><p>第一类用于非 TLB 重填例外情况下 TLB 的交互接口，</p></li>
<li><p>第二类用于软硬件页表遍历，</p></li>
<li><p>第三类用于 TLB 重填例外。</p></li>
</ol>
<p><strong>第一类包括</strong>：</p>
<ul class="simple">
<li><p>❖ BADV：该寄存器用于触发地址错误相关例外时，记录出错的虚地址。此类例外包括下面：</p>
<ul>
<li><p>取指地址错例外（ADEF），此时记录的是该指令的 PC。</p></li>
<li><p>load/store 操作地址错例外（ADEM）</p></li>
<li><p>地址对齐错例外（ALE）</p></li>
<li><p>边界约束检查错例外（BCE）</p></li>
<li><p>load 操作页无效例外（PIL）</p></li>
<li><p>store 操作页无效例外（PIS）</p></li>
<li><p>取指操作页无效例外（PIF）</p></li>
<li><p>页修改例外（PME）</p></li>
<li><p>页不可读例外（PNR）</p></li>
<li><p>页不可执行例外（PNX）</p></li>
<li><p>页特权等级不合规例外（PPI）</p></li>
</ul>
</li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GRLEN-1:0</td>
<td>VAddr</td>
<td>RW</td>
<td>当触发地址错误相关例外时，硬件将出错的虚地址记录于此。对于 LA64 <br>架构，在这种情况下，如果触发例外的特权等级处于 32 位地址模式，那么记录的虚地址的高 32位强制置为 0。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖ TLBEHI：TLB 表项高位寄存器，该寄存器包含 TLB 指令操作时与 TLB 表项高位部分虚页号相关的信息。<br />
因 TLB 表项高位所含的VPPN域的位宽与实现所支持的有效虚地址范围相关。</p></li>
</ul>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>位</p></th>
<th class="head"><p>名字</p></th>
<th class="head"><p>读写</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12:0</p></td>
<td><p>0</p></td>
<td><p>R</p></td>
<td><p>只读恒为 0，写被忽略。</p></td>
</tr>
<tr class="row-odd"><td><p>VALEN-1:13</p></td>
<td><p>VPPN</p></td>
<td><p>RW</p></td>
<td><p>执行 TLBRD 指令时，所读取 TLB 表项的 VPPN 域的值记录到这里。<br>在 CSR.TLBRERA.IsTLBR=0 时，执行 TLBSRCH 指令时查询 TLB 所用 VPPN 值，以及执<br>行 TLBWR 和 TLBFILL 指令时写入 TLB 表项的 VPPN 域的值来自于此。<br>当触发 load 操作页无效例外、store 操作页无效例外、取指操作页无效例外、页修改<br>例外、页不可读例外、页不可执行例外和页特权等级不合规例外时，触发例外的虚地<br>址的[VALEN-1:13]位被记录到这里。</p></td>
</tr>
<tr class="row-even"><td><p>63:VALEN</p></td>
<td><p>Sign_Ext</p></td>
<td><p>R</p></td>
<td><p>读返回值是 VPPN 域最高位的符号扩展，写这些位被忽略。</p></td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖ TLBELO0： TLB 表项低位0</p></li>
<li><p>❖ TLBELO1： TLB 表项低位1
TLBELO0 和 TLBELO1 两个寄存器包含了 TLB 指令操作时 TLB 表项低位部分物理页号等相关的信息。<br />
因龙芯架构下 TLB 采用双页结构，所以 TLB 表项的低位信息对应奇偶两个物理页表项，其中偶数页信息在<br />
TLBELO0 中，奇数页信息在 TLBELO1 中。TLBELO0 和 TLBELO1 寄存器的格式定义完全相同。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>V</td>
<td>RW</td>
<td>页表项的有效位（V）。</td>
</tr>
<tr>
<td>1</td>
<td>D</td>
<td>RW</td>
<td>页表项的脏位（D）。</td>
</tr>
<tr>
<td>3:2</td>
<td>PLV</td>
<td>RW</td>
<td>页表项的特权等级（PLV）。</td>
</tr>
<tr>
<td>5:4</td>
<td>MAT</td>
<td>RW</td>
<td>页表项的存储访问类型（MAT）。</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>RW</td>
<td>页表项的全局标志位（G）。执行 TLBFILL 和 TLBWR 指令时，<br>仅当 TLBELO0 和 TLBELO1 中的 G 位均为 1 时，填入到 TLB 中的页表项的 G 位才为 1。<br>执行 TLBRD 指令时，当所读取的 TLB 表项的 G 位为 1，<br>则 TLBELO0 和 TLBELO1 中的G 位被同时置为 1。</td>
</tr>
<tr>
<td>11:7</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>PALEN-1:12</td>
<td>PPN</td>
<td>RW</td>
<td>页表的物理页号（PPN）。</td>
</tr>
<tr>
<td>60:PALEN</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>61</td>
<td>NR</td>
<td>RW</td>
<td>页表项的不可读位（NR）。</td>
</tr>
<tr>
<td>62</td>
<td>NX</td>
<td>RW</td>
<td>页表项的不可执行位（NX）。</td>
</tr>
<tr>
<td>63</td>
<td>RPLV</td>
<td>RW</td>
<td>页表的受限特权等级使能（RPLV）。当 RPLV=0 时，<br>该页表项可以被任何特权等级不低于 PLV 的程序访问；<br>当 RPLV=1 时，该页表项仅可以被特权等级等于 PLV 的程序访问。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖ TLBIDX： 该寄存器包含 TLB 指令操作 TLB 时相关的索引值等信息。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>n-1:0</td>
<td>Index</td>
<td>RW</td>
<td>执行 TLBRD 和 TLBWR 指令时，访问 TLB 表项的索引值来自于此。<br>执行 TLBSRCH 指令时，如果命中，则命中项的索引值记录到这里。<br>有关索引值与 TLB 表项间的对应关系，请参看 4.2.4.1 节中的相关内容。</td>
</tr>
<tr>
<td>15:n</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>23:16</td>
<td>0</td>
<td>R0</td>
<td>保留域。读返回 0，且软件不允许改变其值。</td>
</tr>
<tr>
<td>29:24</td>
<td>PS</td>
<td>RW</td>
<td>执行 TLBRD 指令时，所读取 TLB 表项的 PS 域的值记录到这里。<br>在 CSR.TLBRERA.IsTLBR=0 时，执行 TLBWR 和 TLBFILL 指令，<br>写入的 TLB 表项的 PS域的值来自于此。</td>
</tr>
<tr>
<td>30</td>
<td>0</td>
<td>R0</td>
<td>保留域。读返回 0，且软件不允许改变其值。</td>
</tr>
<tr>
<td>31</td>
<td>NE</td>
<td>RW</td>
<td>该位为 1 表示该 TLB 表项为空（无效 TLB 表项），为 0 表示该 <br>TLB 表项非空（有效TLB 表项）。执行 TLBSRCH 时，如果有命中项该位记为 0，否则该位记为 1。<br>执行 TLBRD 时，所读取 TLB 表项的 E 位信息取反后记录到这里。执行 TLBWR 或 TLBFILL 指令时，<br>若 CSR.TLBRERA.IsTLBR=0，将该位的值取反后写入到被写 TLB 项的 E 位；若此时 CSR.TLBRERA.IsTLBR=1，<br>那么被写入的 TLB 项的 E 位总是置为 1，与该位的值无关。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖ ASID：地址空间标识符</p></li>
</ul>
<p>该寄存器中包含了用于访存操作和 TLB 指令的地址空间标识符（ASID）信息。ASID 的位宽随着架构<br />
规范的演进可能进一步增加，为方便软件明确 ASID 的位宽，将直接给出这一信息。</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>9:0</td>
<td>ASID</td>
<td>RW</td>
<td>当前执行的程序所对应的地址空间标识符。在取指、执行 load/store 指令时，<br>作为查询 TLB 的 ASID 键值信息。<br>执行 TLBSRCH 和 TLBCLR 指令时，作为查询 TLB 的 ASID 键值信息。<br>执行 TLBWR 或 TLBFILL 指令时，写入 TLB 表项 ASID 域的值来自于此。<br>执行 TLBRD 指令时，所读取的 TLB 表项的 ASID 域的内容记录到这里。</td>
</tr>
<tr>
<td>15:10</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>23:16</td>
<td>ASIDBITS</td>
<td>R</td>
<td>ASID 域的位宽。其直接等于这个域的数值。</td>
</tr>
<tr>
<td>31:24</td>
<td>0</td>
<td>R0</td>
<td>保留域。读返回 0，且软件不允许改变其值。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖ STLBPS： STLB 页大小，该寄存器用于配置 STLB 中页的大小。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>5:0</td>
<td>PS</td>
<td>RW</td>
<td>STLB 的页大小的 2 的幂指数。例如，若页大小为 16KB，则 PS=0xE。</td>
</tr>
<tr>
<td>31:6</td>
<td>0</td>
<td>R0</td>
<td>保留域。读返回 0，且软件不允许改变其值。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<p id="csr-pgd-ctx"><strong>第二类包括</strong>：</p>
<ul class="simple">
<li><p>❖PGDL：低半地址空间全局目录基址，该寄存器用于配置低半地址空间的全局目录的基址。要求全局目录的基址一定是4KB<br />
边界地址对齐的，所以该寄存器的最低 12 位软件不可配置，只读恒为 0。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>11:0</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>GRLEN-1:12</td>
<td>Base</td>
<td>RW</td>
<td>低半地址空间的全局目录的基址。所谓低半地址空间是指虚地址的第[VALEN-1]位<strong>等于 0</strong>。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖PGDH：高半地址空间全局目录基址，该寄存器用于配置高半地址空间的全局目录的基址。要求全局目录的基址一定是 4KB<br />
边界地址对齐的，所以该寄存器的最低 12 位软件不可配置，只读恒为 0。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>11:0</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>GRLEN-1:12</td>
<td>Base</td>
<td>RW</td>
<td>高半地址空间的全局目录的基址。所谓高半地址空间是指虚地址的第[VALEN-1]位<strong>等于 1</strong>。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖PGD: 全局目录基址, 该寄存器是一个只读寄存器，其内容是当前上下文中出错虚地址所对应的全局目录基址信息。该寄存<br />
器的只读信息，不仅用于 CSR 类指令的读返回值，也用于 LDDIR 指令访问全局目录时所需的基址信息。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>11:0</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>GRLEN-1:12</td>
<td>Base</td>
<td>R</td>
<td>如果当前上下文中出错虚地址的最高位是 0，读返回值等于 CSR.PGDL 的 Base 域；<br>否则，读返回值等于 CSR.PGDH 的 Base 域。<br>当 CSR.TLBRERA.IsTLBR=0 时，当前上下文中出错虚地址信息位于 CSR.BADV 中；<br>否则，出错虚地址信息位于 CSR.TLBRBADV 中。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖PWCL：页表遍历控制低半部分，该寄存器和 CSR.PWCH 寄存器中的信息在一起定义了操作系统中所采用的页表结构。<br />
这些信息将用于指示软件或硬件进行页表遍历</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>4:0</td>
<td>PTbase</td>
<td>RW</td>
<td>末级页表（第 0 级页表）的起始地址。</td>
</tr>
<tr>
<td>9:5</td>
<td>PTwidth</td>
<td>RW</td>
<td>末级页表（第 0 级页表）的索引位数。</td>
</tr>
<tr>
<td>14:10</td>
<td>Dir1_base</td>
<td>RW</td>
<td>最低一级目录（第 1 级页表）的起始地址。</td>
</tr>
<tr>
<td>19:15</td>
<td>Dir1_width</td>
<td>RW</td>
<td>最低一级目录（第 1 级页表）的索引位数。0 表示没有这一级。</td>
</tr>
<tr>
<td>24:20</td>
<td>Dir2_base</td>
<td>RW</td>
<td>次低一级目录（第 2 级页表）的起始地址。</td>
</tr>
<tr>
<td>29:25</td>
<td>Dir2_width</td>
<td>RW</td>
<td>次低一级目录（第 2 级页表）的索引位数。0 表示没有这一级。</td>
</tr>
<tr>
<td>31:30</td>
<td>PTEWidth</td>
<td>RW</td>
<td>内存中每个页表项的位宽。<br>0 表示 64 比特，1 表示 128 比特，2 表示 256 比特，3 表示 512 比特。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖PWCH</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>5:0</td>
<td>Dir3_base</td>
<td>RW</td>
<td>次高一级目录（第 3 级页表）的起始地址。</td>
</tr>
<tr>
<td>11:6</td>
<td>Dir3_width</td>
<td>RW</td>
<td>次高一级目录（第 3 级页表）的索引位数。0 表示没有这一级。</td>
</tr>
<tr>
<td>17:12</td>
<td>Dir4_base</td>
<td>RW</td>
<td>最高一级目录（第 4 级页表）的起始地址。</td>
</tr>
<tr>
<td>23:18</td>
<td>Dir4_width</td>
<td>RW</td>
<td>最高一级目录（第 4 级页表）的索引位数。0 表示没有这一级。</td>
</tr>
<tr>
<td>24</td>
<td>0</td>
<td>0</td>
<td>当实现不支持硬件页表遍历（CPUCFG.2.HPTW[bit24]=0）时，读返回 0，且软件<br>不允许改变其值。</td>
</tr>
<tr>
<td>24</td>
<td>HPTW_En</td>
<td>RW</td>
<td>当实现支持硬件页表遍历（CPUCFG.2.HPTW[bit24]=1）时，该位为硬件<br>页表遍历功能的使能位，置 1 开启，置 0 关闭。</td>
</tr>
<tr>
<td>31:25</td>
<td>0</td>
<td>R0</td>
<td>保留域。读返回 0，且软件不允许改变其值。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<p>主要用于软件TLB重填。
<strong>第三类包括</strong>：</p>
<ul class="simple">
<li><p>❖TLBRENTRY：TLB 重填例外入口地址，该寄存器用于配置 TLB 重填例外的入口地址。由于触发 TLB 重填例外之后，<br />
处理器核<strong>将进入直接地址翻译模式</strong>，所以此处所填<strong>入口地址应当是物理地址</strong>。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>11:0</td>
<td>0</td>
<td>R</td>
<td>TLB 重填例外入口地址[11:0]位。只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>PALEN-1:12</td>
<td>PPN</td>
<td>RW</td>
<td>TLB 重填例外入口地址[PALEN-1:12]位。此处填入的地址应为物理地址。</td>
</tr>
<tr>
<td>63:PALEN</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖TLBRERA：TLB 重填例外返回地址，该寄存器保存 TLB 重填例外处理完毕之后的返回地址。除此之外，<br />
该寄存器还包含用于标识当前例外是 TLB 重填例外的标志位。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>IsTLBR</td>
<td>RW</td>
<td>该位为 1 表示当前处于 TLB 重填例外处理的上下文中。<br>当触发 TLB 重填例外时，硬件将该位置 1。<br>当该位为 1 时，仅在 CSR.ERRCTL.IsMERR=0 的情况下，执行 ERTN 指令会将其清 0，<br>否则保持不变。<br>因为架构中为 TLB 重填例外定义了一套独立的 CSR，所以当该位为 1 时，<br>ERTN 返回时，用于恢复 CSR.CRMD 的信息将来自于 CSR.TLBRPRMD；<br>ERTN 返回地址信息将来自于 CSR.TLBRERA；<br>TLBWR 和 TLBFILL 指 令 待 写 入 的 表 项 信 息 将 来 自 于 CSR.TLBREHI 、<br>CSR.TLBELO0、CSR.TLBELO1；<br>TLBSRCH 指令查询的信息来自于 CSR.TLBREHI；<br>LDDIR、LDPTE 指令执行所需的出错虚地址信息将来自于 CSR.TLBRBADV。</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>GRLEN-1:2</td>
<td>PC</td>
<td>RW</td>
<td>记录触发 TLB 重填例外的指令的 PC 的[GRLEN-1:2]位。当执行 ERTN 指令从 TLB 重填<br>例外处理程序返回时（此时本寄存器 IsTLBR=1 且 CSR.ERRCTL.IsMERR=0），硬件自<br>动将存放在此处的值最低位补上两比特 0 后作为最终的返回地址。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖TLBRBADV：TLB 重填例外出错虚地址，该寄存器用于记录触发 TLB 重填例外的出错虚地址。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GRLEN-1:0</td>
<td>VAddr</td>
<td>RW</td>
<td>当触发 TLB 重填例外时，硬件将出错的虚地址记录与此。对于 LA64 架构，<br>在这种情况下，如果触发例外的特权等级处于 32 位地址模式，<br>那么记录的虚地址的高 32 位强制置为 0。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖TLBREHI：TLB 重填例外表项高位，TLBREHI 寄存器是处于 TLB 重填例外上下文时（此时 CSR.TLBRERA.IsTLBR=1），存放 TLB<br />
指令操作时 TLB 表项低位部分物理页号等相关的信息。TLBREHI 寄存器的格式及各个域的含义分别与 TLBEHI寄存器一样</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>5:0</td>
<td>PS</td>
<td>RW</td>
<td>TLB 重填例外专用的页大小值。即在 CSR.TLBRERA.IsTLBR=1 时，执行 TLBWR<br> 和TLBFILL 指令，写入的 TLB 表项的 PS 域的值来自于此。</td>
</tr>
<tr>
<td>12:6</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>VALEN-1:13</td>
<td>VPPN</td>
<td>RW</td>
<td>在 CSR.TLBRERA.IsTLBR=1 时，执行 TLBSRCH 指令时查询 TLB 所用 VPPN 值，<br>以及执行 TLBWR 和 TLBFILL 指令时写入 TLB 表项的 VPPN 域的值来自于此。<br>当触发 TLB 重填例外时，触发例外的虚地址的[VALEN-1:13]位被记录到这里。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖TLBRELO0： TLB 重填例外表项低位0</p></li>
<li><p>❖TLBRELO1： TLB 重填例外表项低位1</p></li>
</ul>
<p>TLBRELO0/1 两寄存器是处于 TLB 重填例外上下文时（此时 CSR.TLBRERA.IsTLBR=1），存放 TLB<br />
指令操作时 TLB 表项低位部分物理页号等相关的信息。TLBRELO0/1 两寄存器的格式及各个域的含义分别<br />
与 TLBELO0/1 两寄存器一样。</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>V</td>
<td>RW</td>
<td>页表项的有效位（V）。</td>
</tr>
<tr>
<td>1</td>
<td>D</td>
<td>RW</td>
<td>页表项的脏位（D）。</td>
</tr>
<tr>
<td>3:2</td>
<td>PLV</td>
<td>RW</td>
<td>页表项的特权等级（PLV）。</td>
</tr>
<tr>
<td>5:4</td>
<td>MAT</td>
<td>RW</td>
<td>页表项的存储访问类型（MAT）。</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>RW</td>
<td>页表项的全局标志位（G）。执行 TLBFILL 和 TLBWR 指令时，仅当 TLBELO0 和 TLBELO1 中的 G 位均为 1 时，<br>填入到 TLB 中的页表项的 G 位才为 1。</td>
</tr>
<tr>
<td>11:7</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>PALEN-1:12</td>
<td>PPN</td>
<td>RW</td>
<td>页表的物理页号（PPN）。</td>
</tr>
<tr>
<td>60:PALEN</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>61</td>
<td>NR</td>
<td>RW</td>
<td>页表项的不可读位（NR）。</td>
</tr>
<tr>
<td>62</td>
<td>NX</td>
<td>RW</td>
<td>页表项的不可执行位（NX）。</td>
</tr>
<tr>
<td>63</td>
<td>RPLV</td>
<td>RW</td>
<td>页表的受限特权等级使能（RPLV）。当 RPLV=0 时，该页表项可以被任何特权等级<br>不低于 PLV 的程序访问；当 RPLV=1 时，该页表项仅<br>可以被特权等级等于 PLV 的程序访问。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖TLBRPRMD：TLB 重填例外前模式信息，当触发 TLB 重填例外时，硬件会将此时处理器核的特权等级、<br />
客户机模式、全局中断使能和监视点使能位保存至该寄存器中，用于例外返回时恢复处理器核的现场。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1:0</td>
<td>PPLV</td>
<td>RW</td>
<td>当触发 TLB 重填例外时，硬件会将 CSR.CRMD 中 PLV 域的旧值记录在这个域。<br>当 CSR.TLBRERA.IsTLBR=1 时，执行 ERTN 指令从例外处理程序返回时，硬件会将这个域的值恢复到 <br>CSR.CRMD 的 PLV 域。</td>
</tr>
<tr>
<td>2</td>
<td>PIE</td>
<td>RW</td>
<td>当触发 TLB 重填例外时，硬件会将 CSR.CRMD 中 IE 域的旧值记录在这个域。<br>当 CSR.TLBRERA.IsTLBR=1 时，执行 ERTN 指令从例外处理程序返回时，<br>硬件会将这个域的值恢复到 CSR.CRMD 的 IE 域。</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>R</td>
<td>若未实现虚拟化扩展，则该位只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>4</td>
<td>PWE</td>
<td>RW</td>
<td>当触发 TLB 重填例外时，硬件会将 CSR.CRMD 中 WE 域的旧值记录在这个域。<br>当 CSR.TLBRERA.IsTLBR=1 时，执行 ERTN 指令从例外处理程序返回时，硬件会将这<br>个域的值恢复到 CSR.CRMD 的 WE 域。</td>
</tr>
<tr>
<td>31:5</td>
<td>0</td>
<td>R0</td>
<td>保留域。读返回 0，且软件不允许改变其值。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖TLBRSAVE：TLB 重填例外数据保存，该寄存器用于给系统软件暂存数据。每个数据保存寄存器可以存放一个通用寄存器的数据。<br />
之所以额外设置一个供 TLB 重填例外处理程序使用的 SAVE 寄存器，是针对非 TLB 重填例外的处理过<br />
程中触发 TLB 重填例外这一情况。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GRLEN-1:0</td>
<td>Data</td>
<td>RW</td>
<td>仅供软件读写的数据。除执行 CSR 指令外，硬件不会修改该域的内容。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<p>上述各 CSR 寄存器与 TLB 交互的细节，请参考 7.4 节中各 CSR 的详细定义</p>
</section>
<section id="tlb-excption-handle">
<span id="id8"></span><h2><span class="section-number">4.3.4. </span>TLB相关的例外<a class="headerlink" href="#tlb-excption-handle" title="Link to this heading"></a></h2>
<p>TLB 进行虚实地址转换过程由硬件自动完成，但是当 TLB 中没有匹配项，或者尽管匹配但页表项无效<br />
或访问非法时，就需要触发例外，交由操作系统内核或其它监管程序，由软件进一步处理，对 TLB 的内容<br />
进行维护，或对程序执行的合法性做最后裁定。</p>
<p>龙芯架构中与 TLB 管理相关的例外有：</p>
<hr class="docutils" />
<ul class="simple">
<li><p>❖ TLB 重填例外：当访存操作的虚地址在 TLB 中查找没有匹配项时，触发该例外，通知系统软件进<br />
行 TLB 重填工作。该例外拥有独立的例外入口、独立的用于维护例外现场的 CSR 以及一套独立的<br />
TLB 访问接口 CSR，意味着该例外允许在其它例外的处理过程中被触发。TLB 重填例外陷入的同<br />
时，硬件会自动将 CSR.CRMD 的 DA 置为 1，PG 置为 0，即自动进入直接地址翻译模式，从而避<br />
免 TLB 重填例外处理程序自身再次触发 TLB 重填例外，此时例外现场将无法保存与恢复。为了区<br />
分 TLB 重填例外陷入后所使用的 CSR 和其它例外可使用的 CSR，TLB 重填例外陷入的同时，硬<br />
件还会自动将 CSR.TLBRERA.ISTLBR 位置 1。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖ load 操作页无效例外：load 操作的虚地址在 TLB 中找到了匹配项但是匹配页表项的 V=0，将触发<br />
该例外。PIL:</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖ store 操作页无效例外：store 操作的虚地址在 TLB 中找到了匹配项但是匹配页表项的 V=0，将触发<br />
该例外。PIS:</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖ 取指操作页无效例外：取指操作的虚地址在 TLB 中找到了匹配项但是匹配页表项的 V=0，将触发<br />
该例外。PIM:</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖ 页特权等级不合规例外：访存操作的虚地址在 TLB 中找到了匹配且 V=1 的项，但是访问的特权等<br />
级不合规，将触发该例外。特权等级不合规体现为，该页表项的 RPLV=0 且 CSR.CRMD.PLV 值大<br />
于页表项中的 PLV；或是该页表项的 RPLV=1 且 CSR.CRMD.PLV 不等于页表项中的 PLV。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖ 页修改例外：store 操作的虚地址在 TLB 中找到了匹配，且 V=1，且特权等级合规的项，但是该页<br />
表项的 D 位为 0，将触发该例外。</p></li>
</ul>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>在例外中设置D=1，然后返回</p>
</div>
<hr class="docutils" />
<ul class="simple">
<li><p>❖ 页不可读例外：load 操作的虚地址在 TLB 中找到了匹配，且 V=1，且特权等级合规的项，但是该<br />
页表项的 NR 位为 1，将触发该例外。</p></li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li><p>❖ 页不可执行例外：取指操作的虚地址在 TLB 中找到了匹配，且 V=1，且特权等级合规的项，但是<br />
该页表项的 NX 位为 1，将触发该例外。</p></li>
</ul>
</section>
<section id="cputlb">
<span id="cpu-inner-tlb-lookup"></span><h2><span class="section-number">4.3.5. </span>CPU内部TLB查找流程示例<a class="headerlink" href="#cputlb" title="Link to this heading"></a></h2>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>//  va: 待查找虚地址
//  mem_type: 访存操作类型，FETCH 是取指操作，LOAD 是 load 操作，STORE 是 store 操作
//  plv：当前特权等级，即 CSR.CRMD.PLV 的值
//  pa: 转换后的物理地址
//  mat: 转换后得到的存储访问类型
//  VALEN: 虚地址的有效位数
//  PALEN: 物理地址的有效位数
//  STLB[][]: STLB[N][M]表示 STLB 第 N 路第 M 项
//  STLB_WAY: STLB 的路数
//  STLB_INDEX: STLB 每一路组数的 2 的幂指数，即每一路有 2STLB_INDEX 组
//  MTLB[]: MTLB[N]表示 MTLB 的第 N 项
//  MTLB_ENTRIES: MTLB 的项数

/**************************************************
///  查找 STLB
**************************************************/
stlb_found = 0
stlb_ps = CSR.STLBPS.PS
stlb_idx = va[stlb_ps+STLB_INDEX:stlb_ps+1]
for way in range(STLB_WAY)：
   if (STLB[way][stlb_idx].E==1) and
   ((STLB[way][stlb_idx].G==1) or (STLB[way][stlb_idx].ASID==CSR.ASID.ASID))
   and
   (STLB[way][stlb_idx].VPPN[VALEN-1:stlb_ps+1]==va[VALEN-1:stlb_ps+1]) :
      if (stlb_found==0) :
         stlb_found = 1
         if (va[stlb_ps]==0) :
            sfound_v = STLB[way][stlb_idx].V0
            sfound_d = STLB[way][stlb_idx].D0
            sfound_nr = STLB[way][stlb_idx].NR0
            sfound_nx = STLB[way][stlb_idx].NX0
            sfound_mat = STLB[way][stlb_idx].MAT0
            sfound_plv = STLB[way][stlb_idx].PLV0
            sfound_rplv = STLB[way][stlb_idx].RPLV0
            sfound_ppn = STLB[way][stlb_idx].PPN0
         else :
            sfound_v = STLB[way][stlb_idx].V1
            sfound_d = STLB[way][stlb_idx].D1
            sfound_nr = STLB[way][stlb_idx].NR1
            sfound_nx = STLB[way][stlb_idx].NX1
            sfound_mat = STLB[way][stlb_idx].MAT1
            sfound_plv = STLB[way][stlb_idx].PLV1
            sfound_rplv = STLB[way][stlb_idx].RPLV1
            sfound_ppn = STLB[way][stlb_idx].PPN1
      else :
         # 出现多项命中，处理器运行结果不确定

// 此时STLB查找完成


/**************************************************
///  查找 MTLB
**************************************************/

mtlb_found = 0
for i in range(MTLB_ENTRIES) :
   if (MTLB[i].E==1) and
      ((MTLB[i].G==1) or (MTLB[i].ASID==CSR.ASID.ASID)) and
      (MTLB[i].VPPN[VALEN-1:MTLB[i].PS+1]==va[VALEN-1: MTLB[i].PS+1]) :
         if (mtlb_found==0) :
            mtlb_found = 1
            mfound_ps = MTLB[i].PS
            if (va[mfound_ps]==0) :
               mfound_v = MTLB[i].V0
               mfound_d = MTLB[i].D0
               mfound_nr = MTLB[i].NR0
               mfound_nx = MTLB[i].NX0
               mfound_mat = MTLB[i].MAT0
               mfound_plv = MTLB[i].PLV0
               mfound_rplv = MTLB[i].RPLV0
               mfound_ppn = MTLB[i].PPN0
            else :
               mfound_v = MTLB[i].V1
               mfound_d = MTLB[i].D1
               mfound_nr = MTLB[i].NR1
               mfound_nx = MTLB[i].NX1
               mfound_mat = MTLB[i].MAT1
               mfound_plv = MTLB[i].PLV1
               mfound_rplv = MTLB[i].RPLV1
               mfound_ppn = MTLB[i].PPN1
         else:
         #出现多项命中，处理器运行结果不确定

// 此时MTLB查找完成


// 下面按照STLB和MTLB查找的结构处理：

if (stlb_found==1) and (mtlb_found==1) :
   #出现多项命中，处理器运行结果不确定
else if (stlb_found==1) :
   found_v = sfound_v
   found_d = sfound_d
   found_nr = sfound_nr
   found_nx = sfound_nx
   found_mat = sfound_mat
   found_plv = sfound_plv
   found_rplv = sfound_rplv
   found_ppn = sfound_ppn
   found_ps = stlb_ps
else if (mtlb_found==1) :
   found_v = mfound_v
   found_d = mfound_d
   found_nr = mfound_nr
   found_nx = mfound_nx
   found_mat = mfound_mat
   found_plv = mfound_plv
   found_rplv = mfound_rplv
   found_ppn = mfound_ppn
   found_ps = mfound_ps
else :
   // Raise SignalException(TLBR)
   // 报 TLB 重填例外


if (found_v==0) :
   case mem_type :
      FETCH : SignalException(PIF)#报取指操作页无效例外
      LOAD: SignalException(PIL)#报 load 操作页无效例外
      STORE : SignalException(PIS)#报 store 操作页无效例外
else if (mem_type==FETCH) and (found_nx==1) :
   SignalException(PNX)
   #报页不可执行例外
else if ((found_rplv==0) and (plv &gt; found_plv)) or
         ((found_rplv==1) and (plv!= found_plv)) :
   SignalException(PPI)
   #报页特权等级不合规例外
else if (mem_type==LOAD) and (found_nr==1) :
   SignalException(PNR)
   #报页不可读例外
else if (mem_type==STORE) and (found_d==0)
         and ((plv==3) or (CSR.MISC[16+plv]==0)) :
   SignalException(PME)
   #禁止写允许检查功能未开启
   #报页修改例外
else :
   pa = {found_ppn[PALEN-13:found_ps-12], va[found_ps-1:0]}
   mat = found_mat
</pre></div>
</div>
</section>
</section>
<hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="csr-note-explain" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>CSR.CRMD表示是CSR寄存器中的CRMD寄存器，后续我们描述控制与状态寄存器的某一个寄存器XXX时，都使用CSR.XXX的方式。</p>
</aside>
</aside>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
    <a href="index.html" class="btn btn-neutral float-left" title="4. 内存管理" accesskey="p"
      rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    <a href="dmw.html" class="btn btn-neutral float-right" title="4.4. 直接映射翻译模式" accesskey="n"
      rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>

  <hr />

  <div role="contentinfo">
    <p>&#169; 版权所有 2022-2026, 龙芯中科技术有限公司。
      <span class="lastupdated">最后更新于 2026年2月10日 11:15:08.
      </span>

      <!-- 
      <span class="footer-aside">
        <a href="../../龙芯实验室文档.pdf" class="fa fa-file-pdf-o">&nbsp下载 PDF</a>
      </span>
       -->
    </p>
  </div> 

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>