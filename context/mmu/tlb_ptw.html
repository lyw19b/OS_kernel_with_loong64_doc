<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>4.5. 多级页表结构 &mdash; 龙芯实验室文档 V1.0 文档</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=b01b2dd9" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />

  
    <link rel="shortcut icon" href="../../_static/favicon.jpg"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=3f0bcac8"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../_static/copybutton.js?v=f281be69"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
        <script src="../../_static/translations.js?v=beaddf03"></script>
        <script src="../../_static/design-tabs.js?v=f930bc37"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="4.7. Kernel与MMU" href="page_table_in_kernel.html" />
    <link rel="prev" title="4.4. 直接映射翻译模式" href="dmw.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #2980B9" >

          
          
          <img src="../../_static/logo.svg" class="logo" alt="Logo"/>
          <a href="../../index.html" class="icon icon-home">
            龙芯实验室文档
          </a>
              <div class="version">
                V1.0
              </div>
<div role="search">
  <form id="evas-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="搜索文档" aria-label="搜索文档" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="导航菜单">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../preparation/index.html">1. 准备工作</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../preparation/preface.html">1.1. 前言</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../preparation/preface.html#id2">1.1.1. 更新说明</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/preface.html#id3">1.1.2. 仓库地址</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../preparation/tools.html">1.2. 工具链说明</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#gcc">1.2.1. GCC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#llvm">1.2.2. LLVM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#rust">1.2.3. Rust</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../preparation/tools.html#id2">1.3. 模拟器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#qemu">1.3.1. QEMU</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#la-emu">1.3.2. LA_EMU</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../preparation/tools.html#id3">1.4. 操作系统编译</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#loongnix">1.4.1. LoongNix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#uos">1.4.2. UOS</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#deepin">1.4.3. Deepin</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#aosc">1.4.4. AOSC(安同)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preparation/tools.html#linux-kernel">1.4.5. Linux kernel</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../toolchains/index.html">2. 工具链</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/gcc.html">2.1. GCC</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/gcc.html#id1">2.1.1. GCC的相关概念</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id2">2.1.1.1. GCC的基本定义与起源</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id4">2.1.1.2. GCC支持的语言与平台</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id5">2.1.1.3. GCC的核心功能与特点</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id6">2.1.1.4. GCC的最新进展</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id7">2.1.1.5. GCC的应用场景</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/gcc.html#id8">2.1.2. 交叉编译器</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/gcc.html#id9">2.1.3. 常见的类别组合</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/gcc.html#id12">2.1.4. 如何编译交叉编译器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#loongarch64-linux-gnu-sf">2.1.4.1. 如何编译loongarch64-linux-gnu[sf]</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#loongarch64-linux-musl-sf">2.1.4.2. 如何编译loongarch64-linux-musl[sf]</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#crtn-crti-crtbegin-crtend">2.1.4.3. crtn, crti, crtbegin, crtend有什么区别</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/gcc.html#id22">2.1.5. 常用的参数与选项</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#id23">2.1.5.1. GCC常见的参数</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#picpie">2.1.5.2. PIC与PIE的区别是什么</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#loongarch">2.1.5.3. 与LoongArch相关的选项说明</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/gcc.html#c-c">2.1.5.4. C/C++ 预处理器内嵌的宏定义</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/binutils.html">2.2. Binutils</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/binutils.html#gnu-binutils">2.2.1. GNU Binutils的相关说明</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id1">2.2.1.1. <strong>核心定位与背景</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id2">2.2.1.2. <strong>重要组成部分与功能</strong></a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id5">2.2.1.3. <strong>应用场景</strong></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/binutils.html#ld">2.2.2. ld链接器</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id6">2.2.2.1. LD的参数说明</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/binutils.html#readelf">2.2.3. 如何正确的使用readelf</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id7">2.2.3.1. 基础用法与核心选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id11">2.2.3.2. 二、高级用法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id14">2.2.3.3. 三、实战示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id18">2.2.3.4. 四、与其他工具对比</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/binutils.html#objdump">2.2.4. objdump</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id19">2.2.4.1. 一、基础用法与核心选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id25">2.2.4.2. 二、高级用法</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id31">2.2.4.3. 三、典型应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id36">2.2.4.4. 四、与其他工具对比</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id37">2.2.4.5. 五、注意事项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id38">2.2.4.6. 六、实战示例</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/binutils.html#objcopy">2.2.5. objcopy</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id42">2.2.5.1. 一、基础用法与核心选项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id46">2.2.5.2. 二、高级功能</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id51">2.2.5.3. 三、参数详解</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id52">2.2.5.4. 四、典型应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id56">2.2.5.5. 五、常见问题与解决</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id60">2.2.5.6. 六、与其他工具对比</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/binutils.html#id61">2.2.5.7. 七、总结</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/rust.html">2.3. Rust</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/rust.html#id1">2.3.1. Rust的概念</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/rust.html#id2">2.3.1.1. Rust的起源与发展</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/rust.html#id3">2.3.1.2. Rust的核心特性</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/rust.html#id4">2.3.1.3. Rust的应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/rust.html#id5">2.3.1.4. Rust的最新进展</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/rust.html#id6">2.3.1.5. Rust的优缺点</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/rust.html#loongarchtarget">2.3.2. LoongArch支持的target有哪些</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/rust.html#loongarch">2.3.3. 与LoongArch相关的具体参数那些</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/rust.html#laexe">2.3.4. 简单的例子说明如何编译成LA架构的EXE文件</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/builtin.html">2.4. 内嵌的函数与指令包装</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/builtin.html#gcc">2.4.1. GCC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/builtin.html#llvm">2.4.2. LLVM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/builtin.html#rust">2.4.3. Rust</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/builtin.html#loongarch">2.4.3.1. LoongArch包的相关内容</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/assembly.html">2.5. 汇编代码与链接脚本</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/assembly.html#loongarch">2.5.1. 与LoongArch相关的汇编指令</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id2">2.5.1.1. 伪汇编指令</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id3">2.5.1.2. 地址加载指令</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id4">2.5.1.3. 内嵌汇编</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id5">2.5.1.4. 参考阅读</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/assembly.html#id6">2.5.2. 链接脚本</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id7">2.5.2.1. 一、基础语法结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id8">2.5.2.2. 二、核心命令与操作</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id13">2.5.2.3. 三、高级功能</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id17">2.5.2.4. 四、典型应用场景</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id21">2.5.2.5. 五、实战示例</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id24">2.5.2.6. 六、调试与验证</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id25">2.5.2.7. 七、总结</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/assembly.html#id26">2.5.2.8. 以LoongArch为例说明链接脚本</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../toolchains/library.html">2.6. 一些常用的库函数</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/library.html#glibc">2.6.1. GLIBC</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id2">2.6.1.1. 一、核心功能与作用</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id3">2.6.1.2. 二、架构与实现细节</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id4">2.6.1.3. 三、版本演进与升级风险</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id5">2.6.1.4. 四、与其他运行库的对比</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id6">2.6.1.5. 五、开发与调试工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/library.html#musl">2.6.2. MUSL</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#musl-c">2.6.2.1. Musl C 库详解</a></li>
<li class="toctree-l4"><a class="reference internal" href="../toolchains/library.html#id15">2.6.2.2. 总结</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/library.html#memcpy">2.6.3. memcpy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/library.html#memmove">2.6.4. memmove</a></li>
<li class="toctree-l3"><a class="reference internal" href="../toolchains/library.html#memset">2.6.5. memset</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../privilege_isa/index.html">3. 特权态指令</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/csr.html">3.1. CSR寄存器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/csr.html#id1">3.2. CSR指令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../privilege_isa/csr.html#csrrd">3.2.1. CSRRD指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../privilege_isa/csr.html#csrwr">3.2.2. CSRWR指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../privilege_isa/csr.html#csrxchg">3.2.3. CSRXCHG指令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/csr.html#iocsr">3.3. IOCSR指令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../privilege_isa/csr.html#iocsrrd">3.3.1. IOCSRRD指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="../privilege_isa/csr.html#iocsrwr">3.3.2. IOCSRWR指令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/cacop_insn.html">3.4. CPUCFG 指令</a></li>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/cacop_insn.html#cacop">3.5. CACOP 指令</a></li>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/tlb_insn.html">3.6. TLB 与页表指令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../privilege_isa/tlb_insn.html#id1">3.6.1. TLB 相关指令</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#tlbsrch">3.6.1.1. TLBSRCH</a></li>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#tlbrd">3.6.1.2. TLBRD</a></li>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#tlbwr">3.6.1.3. TLBWR</a></li>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#tlbfill">3.6.1.4. TLBFILL</a></li>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#tlbclr">3.6.1.5. TLBCLR</a></li>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#tlbflush">3.6.1.6. TLBFLUSH</a></li>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#invtlb">3.6.1.7. INVTLB</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../privilege_isa/tlb_insn.html#id2">3.6.2. 页表查找指令</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#lddir">3.6.2.1. LDDIR</a></li>
<li class="toctree-l4"><a class="reference internal" href="../privilege_isa/tlb_insn.html#ldpte">3.6.2.2. LDPTE</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../privilege_isa/tlb_insn.html#id3">3.6.3. 应用示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/misc_insn.html">3.7. ERTN指令</a></li>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/misc_insn.html#idle">3.8. IDLE指令</a></li>
<li class="toctree-l2"><a class="reference internal" href="../privilege_isa/misc_insn.html#syscall">3.9. SysCALL指令</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">4. 内存管理</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="tlb_struct.html">4.1. LoongArch的地址管理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tlb_struct.html#id2">4.1.1. 直接地址翻译模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="tlb_struct.html#id3">4.1.2. 映射地址翻译模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="tlb_struct.html#id4">4.1.3. 存储访问的类型</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tlb_struct.html#loongarchtlb">4.2. LoongArch的TLB结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tlb_struct.html#id5">4.2.1. 逻辑组织结构</a></li>
<li class="toctree-l3"><a class="reference internal" href="tlb_struct.html#tlb-cpu">4.2.2. TLB的表项（以CPU的视觉）</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="tlb_struct.html#tlb">4.3. TLB的管理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="tlb_struct.html#id6">4.3.1. TLB的一些概念区分</a></li>
<li class="toctree-l3"><a class="reference internal" href="tlb_struct.html#id7">4.3.2. TLB相关的指令</a></li>
<li class="toctree-l3"><a class="reference internal" href="tlb_struct.html#tlbcsr">4.3.3. TLB相关的CSR</a></li>
<li class="toctree-l3"><a class="reference internal" href="tlb_struct.html#tlb-excption-handle">4.3.4. TLB相关的例外</a></li>
<li class="toctree-l3"><a class="reference internal" href="tlb_struct.html#cputlb">4.3.5. CPU内部TLB查找流程示例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="dmw.html">4.4. 直接映射翻译模式</a><ul>
<li class="toctree-l3"><a class="reference internal" href="dmw.html#csr-dmw-0-3">4.4.1. CSR.DMW[0-3]</a></li>
<li class="toctree-l3"><a class="reference internal" href="dmw.html#id2">4.4.2. 操作系统中如何使用</a><ul>
<li class="toctree-l4"><a class="reference internal" href="dmw.html#dmw">4.4.2.1. DMW的优点</a></li>
<li class="toctree-l4"><a class="reference internal" href="dmw.html#id3">4.4.2.2. DMW的缺点</a></li>
<li class="toctree-l4"><a class="reference internal" href="dmw.html#id4">4.4.2.3. 代码示例如何在内核中使用</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">4.5. 多级页表结构</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">4.5.1. 设计背景与必要性</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">4.5.1.1. 多级页表的结构与层级</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id4">4.5.1.2. 地址转换流程</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id5">4.5.1.3. 多级页表的优势</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">4.5.1.4. 优化机制</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id7">4.5.1.5. 对比不同架构的页表设计</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#loongarch">4.5.2. LoongArch的多级页表结构</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kernel">4.5.2.1. Kernel如何初始化设置多级页表结构</a></li>
<li class="toctree-l4"><a class="reference internal" href="#kb">4.5.2.2. 二级页表，4KB页大小</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id8">4.5.2.3. 二级页表，16KB页大小</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id9">4.5.2.4. 三级页表，4KB页大小</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id10">4.5.2.5. 三级页表，16KB页大小</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id11">4.5.2.6. 四级页表，4KB页大小</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">4.5.2.7. 四级页表，16KB页大小</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id13">4.5.3. 内存中的页表表项（Kernel视角）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id14">4.5.3.1. 基本页表（叶子节点）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id15">4.5.3.2. 大页页表（叶子节点）</a></li>
<li class="toctree-l4"><a class="reference internal" href="#no-leaf-pg-entry">4.5.3.3. 中间指向下一级目录的地址的页表(非叶子节点页表)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id17">4.5.4. 页表的遍历</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#k">4.5.4.1. 以一个例子4K页为例说明：</a></li>
<li class="toctree-l4"><a class="reference internal" href="#m">4.5.4.2. 以一个例子2M页为例说明：</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cputlb">4.6. 从内存中的页表表项到CPU中的TLB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tlbrefill-softeware-ptw">4.6.1. TLBRefill (Softeware PTW)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#csr">4.6.1.1. 相关的CSR寄存器</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id18">4.6.1.2. 重填示例代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id19">4.6.1.3. 两级页表的示例代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="#three-level-page-table-refill">4.6.1.4. 三级页表的示例代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id21">4.6.1.5. 四级页表的示例代码</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hardware-ptw">4.6.2. Hardware PTW</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id22">4.6.3. 页表的刷新</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id23">4.6.3.1. 页表为什么需要刷新</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id24">4.6.3.2. 页表刷新的指令</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id25">4.6.3.3. 页表刷新的例子</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="page_table_in_kernel.html">4.7. Kernel与MMU</a><ul>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#id1">4.7.1. 地址翻译相关的初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#id2">4.7.2. 如何从直接地址翻译模式到映射地址翻译模式</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#id3">4.7.3. 如何建立虚拟地址到物理地址的映射关系</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#id4">4.7.4. 页表的遍历页表</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#tlb">4.7.5. 情况1. 如果TLB中没有映射</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#v-0">4.7.6. 情况2. 如果页表项的V=0</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#d-0">4.7.7. 情况3. 如果写操作页表项D=0</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#id5">4.7.8. 情况4. 如果权限不合法</a></li>
<li class="toctree-l3"><a class="reference internal" href="page_table_in_kernel.html#ptw">4.7.9. 如果使能硬件PTW</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../trap/index.html">5. 中断与异常系统</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../trap/interrupt.html">5.1. 中断</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id2">5.1.1. 线中断</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#ipi">5.1.1.1. 核间中断IPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id3">5.1.1.2. 定时器中断</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id4">5.1.1.3. 性能计数器中断</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id5">5.1.1.4. 外部硬中断</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id6">5.1.1.5. 内部软中断</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id7">5.1.1.6. 中断号</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id8">5.1.2. 消息中断</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id9">5.1.3. 中断的优先级</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id10">5.1.3.1. 线中断的优先级</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/interrupt.html#id11">5.1.3.2. 消息中断的优先级</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id12">5.1.4. 中断的打开与关闭</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id13">5.1.5. 中断的入口地址</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/interrupt.html#id14">5.1.6. 中断的处理流程</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../trap/exception.html">5.2. 例外</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../trap/exception.html#id2">5.2.1. 例外的优先级</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/exception.html#id3">5.2.2. 例外的入口地址</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/exception.html#id4">5.2.3. 例外的处理过程</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../trap/exception.html#id5">5.2.3.1. 普通例外的处理过程</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/exception.html#tlb">5.2.3.2. TLB 重填例外硬件处理过程</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/exception.html#id6">5.2.3.3. 机器错误例外硬件处理过程</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../trap/trap_in_kernel.html">5.3. Kernel与异常</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#expection-entry-selection">5.3.1. 异常的入口地址选择</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../trap/trap_in_kernel.html#id2">5.3.1.1. “统一式”的入口地址</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/trap_in_kernel.html#id3">5.3.1.2. “分离式”的入口地址</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#id4">5.3.2. 异常的初始化</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../trap/trap_in_kernel.html#id5">5.3.2.1. 统一式的初始化</a></li>
<li class="toctree-l4"><a class="reference internal" href="../trap/trap_in_kernel.html#id7">5.3.2.2. 分离式的初始化</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#cpu">5.3.3. 异常发生时，CPU做了什么</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../trap/trap_in_kernel.html#id9">5.4. 特殊异常的处理</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#id10">5.4.1. 定时器中断</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#id11">5.4.2. 系统调用</a></li>
<li class="toctree-l3"><a class="reference internal" href="../trap/trap_in_kernel.html#id12">5.4.3. 非对齐访问</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../smp/index.html">6. SMP多核系统</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../smp/smp.html">6.1. SMP与LoongArch</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../smp/smp.html#ipi">6.1.1. IPI中断</a></li>
<li class="toctree-l3"><a class="reference internal" href="../smp/smp.html#id1">6.1.2. 如何通信</a></li>
<li class="toctree-l3"><a class="reference internal" href="../smp/smp.html#id2">6.1.3. 如何初始化</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../smp/smp.html#linuxsmp">6.2. Linux中SMP的处理（与架构相关）</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../abi/index.html">7. 程序二进制接口</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../abi/new_and_old_world.html">7.1. 新旧世界</a></li>
<li class="toctree-l2"><a class="reference internal" href="../abi/new_and_old_world.html#id2">7.2. 旧世界</a></li>
<li class="toctree-l2"><a class="reference internal" href="../abi/new_and_old_world.html#id3">7.3. 新世界</a></li>
<li class="toctree-l2"><a class="reference internal" href="../abi/new_and_old_world.html#id4">7.4. 新旧世界的区分</a></li>
<li class="toctree-l2"><a class="reference internal" href="../abi/abi.html">7.5. ABI 2.0</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../debug/index.html">8. 调试方法与技巧</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../debug/debug_env.html">8.1. LoongArch最小debug环境搭建</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_env.html#linux-ramdisk">8.1.1. 制作Linux RamDisk</a></li>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_env.html#qemu">8.1.2. 如何在 QEMU 中调试</a></li>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_env.html#id1">8.1.3. 设置断点</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../debug/debug_gdb.html">8.2. GDB的使用</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_gdb.html#id1">8.2.1. 交叉编译环境中的GDB</a></li>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_gdb.html#id2">8.2.2. 常见的GDB命令示例</a></li>
<li class="toctree-l3"><a class="reference internal" href="../debug/debug_gdb.html#id3">8.2.3. 调试指令常见失效状况</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../platform/index.html">9. 平台相关</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../platform/qemu.html">9.1. QEMU</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/qemu.html#virt">9.1.1. Virt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/qemu.html#id1">9.1.2. 设备</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/3a5000.html">9.2. 3A5000芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/3a5000.html#id1">9.2.1. 芯片参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/3a5000.html#id2">9.2.2. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/3a5000.html#id3">9.2.3. 地址空间</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../platform/3a5000.html#id4">9.2.3.1. 结点间物理地址空间</a></li>
<li class="toctree-l4"><a class="reference internal" href="../platform/3a5000.html#id5">9.2.3.2. 结点内物理地址空间</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/3a6000.html">9.3. 3A6000芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/3a6000.html#id1">9.3.1. 芯片参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/3a6000.html#id2">9.3.2. 芯片架构</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/2k3000.html">9.4. 2k3000芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k3000.html#id1">9.4.1. 芯片参数</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/2k1000la.html">9.5. 2k1000LA芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k1000la.html#id1">9.5.1. 芯片参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k1000la.html#id2">9.5.2. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k1000la.html#id3">9.5.3. 芯片功能</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k1000la.html#id4">9.5.4. 地址空间</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/2k0500.html">9.6. 2k0500芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id1">9.6.1. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id2">9.6.2. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id3">9.6.3. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id4">9.6.4. 芯片功能</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id5">9.6.5. 地址空间</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0500.html#id6">9.6.6. 中断配置</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../platform/2k0300.html">9.7. 2k0300芯片</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0300.html#id1">9.7.1. 芯片参数</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0300.html#id2">9.7.2. 芯片架构</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0300.html#id3">9.7.3. 芯片功能</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0300.html#id4">9.7.4. 地址空间</a></li>
<li class="toctree-l3"><a class="reference internal" href="../platform/2k0300.html#id5">9.7.5. 中断配置及路由</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../simd/index.html">10. 高级应用：SMID与向量指令</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../simd/todo.html">10.1. TODO</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../virt/index.html">11. 高级应用：LVZ与虚拟化扩展</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../virt/todo.html">11.1. TODO</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../faq/index.html">12. FAQ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../faq/faq-25.html">12.1. FAQ-25</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="移动版导航菜单"  style="background: #2980B9" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">龙芯实验室文档</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="页面导航">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html"><span class="section-number">4. </span>内存管理</a></li>
      <li class="breadcrumb-item active"><span class="section-number">4.5. </span>多级页表结构</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="id1">
<h1><span class="section-number">4.5. </span>多级页表结构<a class="headerlink" href="#id1" title="Link to this heading"></a></h1>
<p>多级页表（Multi-level Page Table）是现代操作系统内存管理的核心机制，通过分层结构解决单级页表的内存占用过高问题，同时兼顾地址转换效率。以下是其核心原理与实现细节：</p>
<section id="id2">
<h2><span class="section-number">4.5.1. </span>设计背景与必要性<a class="headerlink" href="#id2" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>单级页表的缺陷</p>
<ul class="simple">
<li><p>内存爆炸：64位系统下，单级页表需存储 <code class="docutils literal notranslate"><span class="pre">2^52</span></code> 个页表项（假设页大小4KB），总内存需求达 <code class="docutils literal notranslate"><span class="pre">4PB</span></code>，远超物理内存容量。</p></li>
<li><p>连续存储限制：单级页表必须连续存放，无法动态分配，导致内存碎片化问题严重。</p></li>
</ul>
</li>
<li><p>多级页表的核心思想</p>
<ul class="simple">
<li><p>分层索引：将虚拟地址拆分为多段，逐级映射到物理地址，减少单层表项数量。</p></li>
<li><p>按需分配：仅当虚拟地址被访问时，才创建对应的下级页表，显著降低内存占用。</p></li>
</ul>
</li>
</ol>
<hr class="docutils" />
<section id="id3">
<h3><span class="section-number">4.5.1.1. </span>多级页表的结构与层级<a class="headerlink" href="#id3" title="Link to this heading"></a></h3>
<p>以 <strong>LoongArch64的四级页表</strong>为例（4KB页），虚拟地址拆分为以下部分：</p>
<p>这也是Linux中的常规使用。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>48位虚拟地址 → PGD（9位） + PUD（9位） + PMD（9位） + PT（9位） + 页内偏移（12位）
</pre></div>
</div>
<ul class="simple">
<li><p><strong>PGD（Page Global Directory）</strong>：全局页目录，每个进程独立，存储PUD基地址。</p></li>
<li><p><strong>PUD（Page Upper Directory）</strong>：上级页目录，指向PMD。</p></li>
<li><p><strong>PMD（Page Middle Directory）</strong>：中级页目录，指向PT。</p></li>
<li><p><strong>PT（Page Table）</strong>：最终映射到物理页框（PPN）。</p></li>
</ul>
<p><strong>其他架构示例</strong>：</p>
<ul class="simple">
<li><p><strong>ARMv8</strong>：支持4级页表（L0~L3），可动态切换为3级或2级以适配不同颗粒度（如1GB大页）。</p></li>
<li><p><strong>Linux通用实现</strong>：抽象为PGD→PUD→PMD→PTE四级，兼容不同CPU架构。</p></li>
</ul>
</section>
<hr class="docutils" />
<section id="id4">
<h3><span class="section-number">4.5.1.2. </span>地址转换流程<a class="headerlink" href="#id4" title="Link to this heading"></a></h3>
<p>以LoongArch64为例，虚拟地址转换步骤如下：</p>
<ol class="arabic simple">
<li><p><strong>步骤1： TLB命中检查</strong>：CPU优先查询转换快表（TLB），若命中则直接返回物理地址。</p></li>
<li><p><strong>步骤2： 逐级页表遍历</strong>：</p>
<ul class="simple">
<li><p><strong>步骤1</strong>：从CR3寄存器获取PGD基地址，用PGD索引找到PUD表项。</p></li>
<li><p><strong>步骤2</strong>：从PUD表项获取PMD基地址，用PUD索引找到PMD表项。</p></li>
<li><p><strong>步骤3</strong>：从PMD表项获取PT基地址，用PT索引找到PTE。</p></li>
<li><p><strong>步骤4</strong>：从PTE提取物理页号（PPN），与页内偏移拼接为物理地址。</p></li>
</ul>
</li>
<li><p><strong>步骤3： 缺页处理</strong>：若某级页表项不存在（如PTE未分配），触发缺页中断，由内核分配内存并更新页表。</p></li>
</ol>
</section>
<hr class="docutils" />
<section id="id5">
<h3><span class="section-number">4.5.1.3. </span>多级页表的优势<a class="headerlink" href="#id5" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p><strong>内存效率提升</strong></p>
<ul class="simple">
<li><p>仅分配实际使用的页表层级。例如，若进程仅使用100个虚拟页，四级页表总占用约16KB（而非单级页表的4PB）。</p></li>
</ul>
</li>
<li><p><strong>灵活性与扩展性</strong></p>
<ul class="simple">
<li><p>支持大页（如2MB/1GB），通过设置PS（Page Size）位减少页表层级。</p></li>
<li><p>适配不同架构（如ARM的Stage1/Stage2地址转换）。</p></li>
</ul>
</li>
<li><p><strong>隔离与安全</strong></p>
<ul class="simple">
<li><p>每个进程独立维护页表，确保地址空间隔离。</p></li>
<li><p>通过权限位（R/W、U/S、X）控制内存访问。</p></li>
</ul>
</li>
</ol>
</section>
<hr class="docutils" />
<section id="id6">
<h3><span class="section-number">4.5.1.4. </span>优化机制<a class="headerlink" href="#id6" title="Link to this heading"></a></h3>
<ol class="arabic simple">
<li><p><strong>TLB（Translation Lookaside Buffer）</strong></p>
<ul class="simple">
<li><p>缓存最近访问的页表项，减少多级页表遍历次数。TLB命中率可达90%以上，显著提升性能。</p></li>
</ul>
</li>
<li><p><strong>反向页表（Inverted Page Table）</strong></p>
<ul class="simple">
<li><p>以物理页框号为索引，记录占用该页的进程和虚拟页号。适用于物理内存较小的场景，但地址转换复杂度高。</p></li>
</ul>
</li>
<li><p><strong>巨型页（Huge Pages）</strong></p>
<ul class="simple">
<li><p>跳过中间页表层级，直接映射大块内存。例如，2MB巨型页仅需1级页表项，减少TLB Miss。</p></li>
</ul>
</li>
</ol>
</section>
<hr class="docutils" />
<section id="id7">
<h3><span class="section-number">4.5.1.5. </span>对比不同架构的页表设计<a class="headerlink" href="#id7" title="Link to this heading"></a></h3>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><strong>架构</strong></p></th>
<th class="head"><p><strong>页表层级</strong></p></th>
<th class="head"><p><strong>关键特性</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><strong>x86-64</strong></p></td>
<td><p>4级（PGD→PUD→PMD→PT）</p></td>
<td><p>支持512GB虚拟地址空间，兼容PAE扩展。</p></td>
</tr>
<tr class="row-odd"><td><p><strong>ARMv8</strong></p></td>
<td><p>4级（L0~L3）</p></td>
<td><p>支持Stage1（虚拟地址到中间物理地址）和Stage2（中间到物理地址）转换。</p></td>
</tr>
<tr class="row-even"><td><p><strong>RISC-V</strong></p></td>
<td><p>2~4级可配置</p></td>
<td><p>灵活适配不同内存需求，常见于嵌入式系统。</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<hr class="docutils" />
<section id="loongarch">
<h2><span class="section-number">4.5.2. </span>LoongArch的多级页表结构<a class="headerlink" href="#loongarch" title="Link to this heading"></a></h2>
<p>龙架构的多级页表结构如下图所示：</p>
<a class="bg-primary reference internal image-reference" href="../../_images/loongarch-multi-level-page.png"><img alt="LoongArch Multi-Level Page Table" class="bg-primary align-center" src="../../_images/loongarch-multi-level-page.png" style="width: 954.0px; height: 682.0px;" /></a>
<p>上述图中的CSR中的PGDL，PGDH，PWCL，PWCH寄存器。下面是具体的位宽说明：</p>
<hr class="docutils" />
<ul class="simple">
<li><p>❖PWCH</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>5:0</td>
<td>Dir3_base</td>
<td>RW</td>
<td>次高一级目录（第 3 级页表）的起始地址。</td>
</tr>
<tr>
<td>11:6</td>
<td>Dir3_width</td>
<td>RW</td>
<td>次高一级目录（第 3 级页表）的索引位数。0 表示没有这一级。</td>
</tr>
<tr>
<td>17:12</td>
<td>Dir4_base</td>
<td>RW</td>
<td>最高一级目录（第 4 级页表）的起始地址。</td>
</tr>
<tr>
<td>23:18</td>
<td>Dir4_width</td>
<td>RW</td>
<td>最高一级目录（第 4 级页表）的索引位数。0 表示没有这一级。</td>
</tr>
<tr>
<td>24</td>
<td>0</td>
<td>0</td>
<td>当实现不支持硬件页表遍历（CPUCFG.2.HPTW[bit24]=0）时，读返回 0，且软件<br>不允许改变其值。</td>
</tr>
<tr>
<td>24</td>
<td>HPTW_En</td>
<td>RW</td>
<td>当实现支持硬件页表遍历（CPUCFG.2.HPTW[bit24]=1）时，该位为硬件<br>页表遍历功能的使能位，置 1 开启，置 0 关闭。</td>
</tr>
<tr>
<td>31:25</td>
<td>0</td>
<td>R0</td>
<td>保留域。读返回 0，且软件不允许改变其值。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖PWCL：页表遍历控制低半部分，该寄存器和 CSR.PWCH 寄存器中的信息在一起定义了操作系统中所采用的页表结构。<br />
这些信息将用于指示软件或硬件进行页表遍历</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>4:0</td>
<td>PTbase</td>
<td>RW</td>
<td>末级页表（第 0 级页表）的起始地址。</td>
</tr>
<tr>
<td>9:5</td>
<td>PTwidth</td>
<td>RW</td>
<td>末级页表（第 0 级页表）的索引位数。</td>
</tr>
<tr>
<td>14:10</td>
<td>Dir1_base</td>
<td>RW</td>
<td>最低一级目录（第 1 级页表）的起始地址。</td>
</tr>
<tr>
<td>19:15</td>
<td>Dir1_width</td>
<td>RW</td>
<td>最低一级目录（第 1 级页表）的索引位数。0 表示没有这一级。</td>
</tr>
<tr>
<td>24:20</td>
<td>Dir2_base</td>
<td>RW</td>
<td>次低一级目录（第 2 级页表）的起始地址。</td>
</tr>
<tr>
<td>29:25</td>
<td>Dir2_width</td>
<td>RW</td>
<td>次低一级目录（第 2 级页表）的索引位数。0 表示没有这一级。</td>
</tr>
<tr>
<td>31:30</td>
<td>PTEWidth</td>
<td>RW</td>
<td>内存中每个页表项的位宽。<br>0 表示 64 比特，1 表示 128 比特，2 表示 256 比特，3 表示 512 比特。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖PGD: 全局目录基址, 该寄存器是一个只读寄存器，其内容是当前上下文中出错虚地址所对应的全局目录基址信息。该寄存<br />
器的只读信息，不仅用于 CSR 类指令的读返回值，也用于 LDDIR 指令访问全局目录时所需的基址信息。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>11:0</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>GRLEN-1:12</td>
<td>Base</td>
<td>R</td>
<td>如果当前上下文中出错虚地址的最高位是 0，读返回值等于 CSR.PGDL 的 Base 域；<br>否则，读返回值等于 CSR.PGDH 的 Base 域。<br>当 CSR.TLBRERA.IsTLBR=0 时，当前上下文中出错虚地址信息位于 CSR.BADV 中；<br>否则，出错虚地址信息位于 CSR.TLBRBADV 中。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖PGDL：低半地址空间全局目录基址，该寄存器用于配置低半地址空间的全局目录的基址。要求全局目录的基址一定是4KB<br />
边界地址对齐的，所以该寄存器的最低 12 位软件不可配置，只读恒为 0。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>11:0</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>GRLEN-1:12</td>
<td>Base</td>
<td>RW</td>
<td>低半地址空间的全局目录的基址。所谓低半地址空间是指虚地址的第[VALEN-1]位<strong>等于 0</strong>。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖PGDH：高半地址空间全局目录基址，该寄存器用于配置高半地址空间的全局目录的基址。要求全局目录的基址一定是 4KB<br />
边界地址对齐的，所以该寄存器的最低 12 位软件不可配置，只读恒为 0。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>11:0</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>GRLEN-1:12</td>
<td>Base</td>
<td>RW</td>
<td>高半地址空间的全局目录的基址。所谓高半地址空间是指虚地址的第[VALEN-1]位<strong>等于 1</strong>。</td>
</tr>
</tbody>
</table>
<section id="kernel">
<h3><span class="section-number">4.5.2.1. </span>Kernel如何初始化设置多级页表结构<a class="headerlink" href="#kernel" title="Link to this heading"></a></h3>
<p>根据上面的说明，内核要想正确的使用虚拟地址转换，需要正确的设置多级页表结构。不像RISC-V，页大小和虚拟地址的划分是确定的如下所示：</p>
<p>在Sv39的模式下，页大小4KB，此模式下虚拟地址只用了VA[38:0]</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">VPN</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">38</span><span class="p">:</span><span class="mi">30</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">29</span><span class="p">:</span><span class="mi">21</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">20</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span>
<span class="n">Page</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">11</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>在Sv48的模式下，页大小4KB，此模式下虚拟地址只用了VA[47:0]</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">VPN</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">47</span><span class="p">:</span><span class="mi">39</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">38</span><span class="p">:</span><span class="mi">30</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">29</span><span class="p">:</span><span class="mi">21</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">20</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span>
<span class="n">Page</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">11</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>而在LoongArch中，虚拟地址VPN的划分是比较灵活，示意图如上面所示。全是由PWCH、PWCL等寄存器中的域<code class="docutils literal notranslate"><span class="pre">dir[x]_base、dir[x]_width和PT_Base</span></code>确定。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>因此，在LoongArch中，通过给PWCL和PWCH状态控制寄存器设置合理的值，就能够使用<strong>多种页大小的多级分页机制</strong>！</p>
</div>
<p>下面我们会以例子的方式，说明如何设置CPU多级页表访问。</p>
<p>下面的举例都是以LoongArch64为例。内存中页表项的大小是64-Bit也就是8-Byte。</p>
</section>
<section id="kb">
<h3><span class="section-number">4.5.2.2. </span>二级页表，4KB页大小<a class="headerlink" href="#kb" title="Link to this heading"></a></h3>
<p>页表偏移 Page_Offset = VA[11:0]</p>
<p>然后VPN[x]的大小为Log2(4KB/8B)= 9位，因此</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">VPN</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">29</span><span class="p">:</span><span class="mi">21</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">20</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span>
<span class="n">Page</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">11</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>这样的话虚拟地址只使用了VA[29:0]共30位，内存空间大小[0 - 1G]。</p>
<ul class="simple">
<li><p>因此，PWCL和PWCH寄存器设置如下（可以是下面的配置）：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Dir4_base  = 0
Dir4_width = 0

Dir3_base  = 0
Dir3_width = 0

Dir2_base  = 0
Dir2_width = 0

// VPN宽度9，起始地址为21 
Dir1_base  = 0x15（或者十进制21）
Dir1_width = 0x9  (十进制9)

// VPN宽度9，起始地址为12 
PTbase  = 0xc （或者十进制12）
PTwidth = 0x9  (十进制9)

// 页表表项64-bit
PTEWidth = 0
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CSR.PWCH</span> <span class="pre">=</span> <span class="pre">0x0，</span> <span class="pre">CSR.PWCL</span> <span class="pre">=</span> <span class="pre">0x4d52c</span></code></p>
<ul class="simple">
<li><p>或者是如下的配置也是可以的</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Dir4_base  = 0
Dir4_width = 0 //如果没有必须设置成0

// VPN宽度9，起始地址为21 
Dir3_base  = 0x15（或者十进制21）
Dir3_width = 0x9  (十进制9)

Dir2_base  = 0
Dir2_width = 0 //如果没有必须设置成0

Dir1_base  = 0
Dir1_width = 0 //如果没有必须设置成0

// VPN宽度9，起始地址为12 
PTbase  = 0xc （或者十进制12）
PTwidth = 0x9  (十进制9)

// 页表表项64-bit
PTEWidth = 0
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CSR.PWCH</span> <span class="pre">=</span> <span class="pre">0x255，</span> <span class="pre">CSR.PWCL</span> <span class="pre">=</span> <span class="pre">0x12c</span></code></p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>上述只要保证只有两个<code class="docutils literal notranslate"><span class="pre">Dir3_width,</span> <span class="pre">PTwidth</span></code>或者<code class="docutils literal notranslate"><span class="pre">Dir1_width,</span> <span class="pre">PTwidth</span></code>有效即可！</p>
<p>还可以是其他的选项，只要保证起始位置和宽度正确满足规定。</p>
</div>
</section>
<section id="id8">
<h3><span class="section-number">4.5.2.3. </span>二级页表，16KB页大小<a class="headerlink" href="#id8" title="Link to this heading"></a></h3>
<p>页表偏移 Page_Offset = VA[13:0]</p>
<p>然后VPN[x]的大小为Log2(16KB/8B)= 11位，因此</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">VPN</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">25</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">24</span><span class="p">:</span><span class="mi">14</span><span class="p">]</span>
<span class="n">Page</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>这样的话虚拟地址只使用了VA[35:0]共36位。</p>
<ul class="simple">
<li><p>因此，PWCL和PWCH寄存器设置如下（可以是下面的配置）：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Dir4_base  = 0
Dir4_width = 0

Dir3_base  = 0
Dir3_width = 0

Dir2_base  = 0
Dir2_width = 0

// VPN宽度11，起始地址为25 
Dir1_base  = 0x19（或者十进制25）
Dir1_width = 0xb  (十进制11)

// VPN宽度11，起始地址为14 
PTbase  = 0xe （或者十进制14）
PTwidth = 0xb  (十进制11)

// 页表表项64-bit
PTEWidth = 0
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CSR.PWCH</span> <span class="pre">=</span> <span class="pre">0x0，</span> <span class="pre">CSR.PWCL</span> <span class="pre">=</span> <span class="pre">0x5e56e</span></code></p>
<ul class="simple">
<li><p>或者是如下的配置也是可以的</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Dir4_base  = 0
Dir4_width = 0 //如果没有必须设置成0

// VPN宽度11，起始地址为25 
Dir3_base  = 0x19（或者十进制25）
Dir3_width = 0xb  (十进制11)

Dir2_base  = 0
Dir2_width = 0 //如果没有必须设置成0

Dir1_base  = 0
Dir1_width = 0 //如果没有必须设置成0

// VPN宽度11，起始地址为14 
PTbase  = 0xe （或者十进制14）
PTwidth = 0xb  (十进制11)

// 页表表项64-bit
PTEWidth = 0
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CSR.PWCH</span> <span class="pre">=</span> <span class="pre">0x2d9，</span> <span class="pre">CSR.PWCL</span> <span class="pre">=</span> <span class="pre">0x16e</span></code></p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>上述只要保证只有两个<code class="docutils literal notranslate"><span class="pre">Dir3_width,</span> <span class="pre">PTwidth</span></code>或者<code class="docutils literal notranslate"><span class="pre">Dir1_width,</span> <span class="pre">PTwidth</span></code></p>
<p>或者<code class="docutils literal notranslate"><span class="pre">Dir2_width,</span> <span class="pre">PTwidth</span></code>有效即可！</p>
<p>还可以是其他的选项，只要保证起始位置和宽度正确满足规定。</p>
</div>
</section>
<section id="id9">
<h3><span class="section-number">4.5.2.4. </span>三级页表，4KB页大小<a class="headerlink" href="#id9" title="Link to this heading"></a></h3>
<p>页表偏移 Page_Offset = VA[11:0]</p>
<p>然后VPN[x]的大小为Log2(4KB/8B)= 9位，因此</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">VPN</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">38</span><span class="p">:</span><span class="mi">30</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">29</span><span class="p">:</span><span class="mi">21</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">20</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span>
<span class="n">Page</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">11</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>这样的话虚拟地址只使用了VA[38:0]共39位，内存空间大小[0 - 0xFFFFFFFFFF]。</p>
<ul class="simple">
<li><p>因此，PWCL和PWCH寄存器设置如下（可以是下面的配置）：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Dir4_base  = 0
Dir4_width = 0

Dir3_base  = 0
Dir3_width = 0

// VPN宽度9，起始地址为30 
Dir2_base  = 0x1e
Dir2_width = 0x9

// VPN宽度9，起始地址为21 
Dir1_base  = 0x15（或者十进制21）
Dir1_width = 0x9  (十进制9)

// VPN宽度9，起始地址为12 
PTbase  = 0xc （或者十进制12）
PTwidth = 0x9  (十进制9)

// 页表表项64-bit
PTEWidth = 0
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CSR.PWCH</span> <span class="pre">=</span> <span class="pre">0x0，</span> <span class="pre">CSR.PWCL</span> <span class="pre">=</span> <span class="pre">0x13e4d52c</span></code></p>
<ul class="simple">
<li><p>或者是如下的配置也是可以的</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Dir4_base  = 0
Dir4_width = 0 //如果没有必须设置成0

// VPN宽度9，起始地址为30 
Dir3_base  = 0x1e
Dir3_width = 0x9

Dir2_base  = 0
Dir2_width = 0 //如果没有必须设置成0

// VPN宽度9，起始地址为21 
Dir1_base  = 0x15（或者十进制21）
Dir1_width = 0x9  (十进制9)

// VPN宽度9，起始地址为12 
PTbase  = 0xc （或者十进制12）
PTwidth = 0x9  (十进制9)

// 页表表项64-bit
PTEWidth = 0
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CSR.PWCH</span> <span class="pre">=</span> <span class="pre">0x25e，</span> <span class="pre">CSR.PWCL</span> <span class="pre">=</span> <span class="pre">0x4d52c</span></code></p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>上述只要保证只有两个<code class="docutils literal notranslate"><span class="pre">Dir3_width,</span> <span class="pre">Dir1_width,</span> <span class="pre">PTwidth</span></code>或者<code class="docutils literal notranslate"><span class="pre">Dir2_width,</span> <span class="pre">Dir1_width,</span> <span class="pre">PTwidth</span></code>有效即可！</p>
<p>还可以是其他的选项，只要保证起始位置和宽度正确满足规定。</p>
</div>
</section>
<section id="id10">
<h3><span class="section-number">4.5.2.5. </span>三级页表，16KB页大小<a class="headerlink" href="#id10" title="Link to this heading"></a></h3>
<p>页表偏移 Page_Offset = VA[13:0]</p>
<p>然后VPN[x]的大小为Log2(16KB/8B)= 11位，因此</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">VPN</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">46</span><span class="p">:</span><span class="mi">36</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">25</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">24</span><span class="p">:</span><span class="mi">14</span><span class="p">]</span>
<span class="n">Page</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>这样的话虚拟地址只使用了VA[46:0]共47位。</p>
<ul class="simple">
<li><p>因此，PWCL和PWCH寄存器设置如下（可以是下面的配置）：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Dir4_base  = 0
Dir4_width = 0

Dir3_base  = 0
Dir3_width = 0

// VPN宽度11，起始地址为36 
Dir2_base  = 024  (十进制36)
Dir2_width = 0xb  (十进制11)

// VPN宽度11，起始地址为25 
Dir1_base  = 0x19 (或者十进制25)
Dir1_width = 0xb  (十进制11)

// VPN宽度11，起始地址为14 
PTbase  = 0xe  (或者十进制14)
PTwidth = 0xb  (十进制11)

// 页表表项64-bit
PTEWidth = 0
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CSR.PWCH</span> <span class="pre">=</span> <span class="pre">0x0，</span> <span class="pre">CSR.PWCL</span> <span class="pre">=</span> <span class="pre">0x1645e56e</span></code></p>
<ul class="simple">
<li><p>或者是如下的配置也是可以的</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Dir4_base  = 0
Dir4_width = 0 //如果没有必须设置成0

// VPN宽度11，起始地址为36 
Dir3_base  = 0x24 (十进制36)
Dir3_width = 0xb  (十进制11)

Dir2_base  = 0
Dir2_width = 0 //如果没有必须设置成0

// VPN宽度11，起始地址为25 
Dir1_base  = 0x19 (或者十进制25)
Dir1_width = 0xb  (十进制11)

// VPN宽度11，起始地址为14 
PTbase  = 0xe  (或者十进制14)
PTwidth = 0xb  (十进制11)

// 页表表项64-bit
PTEWidth = 0
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CSR.PWCH</span> <span class="pre">=</span> <span class="pre">0x2e4，</span> <span class="pre">CSR.PWCL</span> <span class="pre">=</span> <span class="pre">0x5e56e</span></code></p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>上述只要保证只有两个<code class="docutils literal notranslate"><span class="pre">Dir3_width,</span> <span class="pre">Dir1_width,</span> <span class="pre">PTwidth</span></code>或者<code class="docutils literal notranslate"><span class="pre">Dir2_width,</span> <span class="pre">Dir1_width,</span> <span class="pre">PTwidth</span></code></p>
<p>或者<code class="docutils literal notranslate"><span class="pre">Dir3_width,</span> <span class="pre">Dir2_width,</span> <span class="pre">PTwidth</span></code>有效即可！</p>
<p>还可以是其他的选项，只要保证起始位置和宽度正确满足规定。</p>
</div>
</section>
<section id="id11">
<h3><span class="section-number">4.5.2.6. </span>四级页表，4KB页大小<a class="headerlink" href="#id11" title="Link to this heading"></a></h3>
<p>页表偏移 Page_Offset = VA[11:0]</p>
<p>然后VPN[x]的大小为Log2(4KB/8B)= 9位，因此</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">VPN</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">47</span><span class="p">:</span><span class="mi">39</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">38</span><span class="p">:</span><span class="mi">30</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">29</span><span class="p">:</span><span class="mi">21</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">20</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span>
<span class="n">Page</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">11</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>这样的话虚拟地址只使用了VA[47:0]共48位，内存空间大小[0 - 0x1FFFFFFFFFFFF]。</p>
<ul class="simple">
<li><p>因此，PWCL和PWCH寄存器设置如下（可以是下面的配置）：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Dir4_base  = 0
Dir4_width = 0

// VPN宽度9，起始地址为39 
Dir3_base  = 0x27 (或者十进制39)
Dir3_width = 0x9  (十进制9)

// VPN宽度9，起始地址为30 
Dir2_base  = 0x1e (或者十进制30)
Dir2_width = 0x9  (十进制9)

// VPN宽度9，起始地址为21 
Dir1_base  = 0x15 (或者十进制21)
Dir1_width = 0x9  (十进制9)

// VPN宽度9，起始地址为12 
PTbase  = 0xc (或者十进制12)
PTwidth = 0x9  (十进制9)

// 页表表项64-bit
PTEWidth = 0
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CSR.PWCH</span> <span class="pre">=</span> <span class="pre">0x267，</span> <span class="pre">CSR.PWCL</span> <span class="pre">=</span> <span class="pre">0x13e4d52c</span></code></p>
<ul class="simple">
<li><p>或者是如下的配置也是可以的</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// VPN宽度9，起始地址为39 
Dir4_base  = 0x27 (或者十进制39)
Dir4_width = 0x9  (十进制9)

Dir3_base  = 0
Dir3_width = 0 //如果没有必须设置成0

// VPN宽度9，起始地址为30 
Dir2_base  = 0x1e (或者十进制30)
Dir2_width = 0x9  (十进制9)

// VPN宽度9，起始地址为21 
Dir1_base  = 0x15（或者十进制21）
Dir1_width = 0x9  (十进制9)

// VPN宽度9，起始地址为12 
PTbase  = 0xc （或者十进制12）
PTwidth = 0x9  (十进制9)

// 页表表项64-bit
PTEWidth = 0
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CSR.PWCH</span> <span class="pre">=</span> <span class="pre">0x267000，</span> <span class="pre">CSR.PWCL</span> <span class="pre">=</span> <span class="pre">0x13e4d52c</span></code></p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>上述只要保证只有两个<code class="docutils literal notranslate"><span class="pre">Dir4_width,</span> <span class="pre">Dir3_width,</span> <span class="pre">Dir1_width,</span> <span class="pre">PTwidth</span></code>或者<code class="docutils literal notranslate"><span class="pre">Dir3_width,</span> <span class="pre">Dir2_width,</span> <span class="pre">Dir1_width,</span> <span class="pre">PTwidth</span></code>有效即可！</p>
<p>还可以是其他的选项，只要保证起始位置和宽度正确满足规定。</p>
</div>
</section>
<section id="id12">
<h3><span class="section-number">4.5.2.7. </span>四级页表，16KB页大小<a class="headerlink" href="#id12" title="Link to this heading"></a></h3>
<p>页表偏移 Page_Offset = VA[13:0]</p>
<p>然后VPN[x]的大小为Log2(16KB/8B)= 11位，因此</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">VPN</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">57</span><span class="p">:</span><span class="mi">47</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">46</span><span class="p">:</span><span class="mi">36</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">25</span><span class="p">]</span>
<span class="n">VPN</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">24</span><span class="p">:</span><span class="mi">14</span><span class="p">]</span>
<span class="n">Page</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">VA</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>这样的话虚拟地址只使用了VA[57:0]共58位。范围是：[0, 0x7FFFFFFFFFFFFFF]</p>
<ul class="simple">
<li><p>因此，PWCL和PWCH寄存器设置如下（可以是下面的配置）：</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Dir4_base  = 0
Dir4_width = 0 //如果没有必须设置成0

// VPN宽度11，起始地址为47 
Dir3_base  = 02f  (十进制47)
Dir3_width = 0xb  (十进制11)

// VPN宽度11，起始地址为36 
Dir2_base  = 024  (十进制36)
Dir2_width = 0xb  (十进制11)

// VPN宽度11，起始地址为25 
Dir1_base  = 0x19 (或者十进制25)
Dir1_width = 0xb  (十进制11)

// VPN宽度11，起始地址为14 
PTbase  = 0xe  (或者十进制14)
PTwidth = 0xb  (十进制11)

// 页表表项64-bit
PTEWidth = 0
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CSR.PWCH</span> <span class="pre">=</span> <span class="pre">0x2ef，</span> <span class="pre">CSR.PWCL</span> <span class="pre">=</span> <span class="pre">0x1645e56e</span></code></p>
<ul class="simple">
<li><p>或者是如下的配置也是可以的</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// VPN宽度11，起始地址为47 
Dir4_base  = 02f  (十进制47)
Dir4_width = 0xb  (十进制11)

Dir3_base  = 0
Dir3_width = 0 //如果没有必须设置成0

// VPN宽度11，起始地址为36 
Dir2_base  = 024  (十进制36)
Dir2_width = 0xb  (十进制11)

// VPN宽度11，起始地址为25 
Dir1_base  = 0x19 (或者十进制25)
Dir1_width = 0xb  (十进制11)

// VPN宽度11，起始地址为14 
PTbase  = 0xe  (或者十进制14)
PTwidth = 0xb  (十进制11)

// 页表表项64-bit
PTEWidth = 0
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CSR.PWCH</span> <span class="pre">=</span> <span class="pre">0x2ef000，</span> <span class="pre">CSR.PWCL</span> <span class="pre">=</span> <span class="pre">0x1645e56e</span></code></p>
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>上述只要保证只有两个<code class="docutils literal notranslate"><span class="pre">Dir4_width,</span> <span class="pre">Dir3_width,</span> <span class="pre">Dir1_width,</span> <span class="pre">PTwidth</span></code>或者<code class="docutils literal notranslate"><span class="pre">Dir3_width,</span> <span class="pre">Dir2_width,</span> <span class="pre">Dir1_width,</span> <span class="pre">PTwidth</span></code> 有效即可！</p>
<p>还可以是其他的选项，只要保证起始位置和宽度正确满足规定。</p>
</div>
<div class="admonition caution">
<p class="admonition-title">小心</p>
<p>上述的配置，(四级页表，4KB页大小)、(四级页表，16KB页大小) 还需要根据具体的CPU实现的VALEN长度来确定，不能无限制的使用！</p>
<p>一般我们选择，(四级页表，4KB页大小)的配置，或者(三级页表，16KB页大小) 的配置，
或者(三级页表，4KB页大小)的配置。</p>
</div>
</section>
</section>
<section id="id13">
<h2><span class="section-number">4.5.3. </span>内存中的页表表项（Kernel视角）<a class="headerlink" href="#id13" title="Link to this heading"></a></h2>
<section id="id14">
<h3><span class="section-number">4.5.3.1. </span>基本页表（叶子节点）<a class="headerlink" href="#id14" title="Link to this heading"></a></h3>
<p>4k, 16k</p>
<a class="bg-primary reference internal image-reference" href="../../_images/base_page_table.png"><img alt="LoongArch Base Page Table" class="bg-primary align-center" src="../../_images/base_page_table.png" style="width: 954.0px; height: 129.0px;" /></a>
<p>其中标志如下所示：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>63</td>
<td>RPLV</td>
<td>RW</td>
<td>页表的受限特权等级使能（RPLV）。当 RPLV=0 时，<br>该页表项可以被任何特权等级不低于 PLV 的程序访问；<br>当 RPLV=1 时，该页表项仅可以被特权等级等于 PLV 的程序访问。</td>
</tr>
<tr>
<td>62</td>
<td>NX</td>
<td>RW</td>
<td>页表项的不可执行位（NX）。</td>
</tr>
<tr>
<td>61</td>
<td>NR</td>
<td>RW</td>
<td>页表项的不可读位（NR）。</td>
</tr>
<tr>
<td>60:PALEN</td>
<td>0</td>
<td>R0</td>
<td>保留域。读返回 0。</td>
</tr>
<tr>
<td>PALEN-1:12</td>
<td>PPN</td>
<td>RW</td>
<td>页表的物理页号（PPN）。</td>
</tr>
<tr>
<td>11:9</td>
<td>0</td>
<td>R0</td>
<td>保留域。读返回 0。</td>
</tr>
<tr>
<td>8</td>
<td>W</td>
<td>RW</td>
<td>对应的物理页是否可写。</td>
</tr>
<tr>
<td>7</td>
<td>P</td>
<td>RW</td>
<td>物理页是否存在。</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>RW</td>
<td>页表项的全局标志位（G）。执行 TLBFILL 和 TLBWR 指令时，<br>仅当 TLBELO0 和 TLBELO1 中的 G 位均为 1 时，填入到 TLB 中的页表项的 G 位才为 1。<br>执行 TLBRD 指令时，当所读取的 TLB 表项的 G 位为 1，<br>则 TLBELO0 和 TLBELO1 中的G 位被同时置为 1。</td>
</tr>
<tr>
<td>5:4</td>
<td>MAT</td>
<td>RW</td>
<td>页表项的存储访问类型（MAT）。</td>
</tr>
<tr>
<td>3:2</td>
<td>PLV</td>
<td>RW</td>
<td>页表项的特权等级（PLV）。</td>
</tr>
<tr>
<td>1</td>
<td>D</td>
<td>RW</td>
<td>页表项的脏位（D）。</td>
</tr>
<tr>
<td>0</td>
<td>V</td>
<td>RW</td>
<td>页表项的有效位（V）。</td>
</tr>
</tbody>
</table>
</section>
<section id="id15">
<h3><span class="section-number">4.5.3.2. </span>大页页表（叶子节点）<a class="headerlink" href="#id15" title="Link to this heading"></a></h3>
<p>2M, 1G</p>
<a class="bg-primary reference internal image-reference" href="../../_images/big_page_table.png"><img alt="LoongArch Big Page Table" class="bg-primary align-center" src="../../_images/big_page_table.png" style="width: 954.0px; height: 121.0px;" /></a>
<p>其中标志如下所示：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>63</td>
<td>RPLV</td>
<td>RW</td>
<td>页表的受限特权等级使能（RPLV）。当 RPLV=0 时，<br>该页表项可以被任何特权等级不低于 PLV 的程序访问；<br>当 RPLV=1 时，该页表项仅可以被特权等级等于 PLV 的程序访问。</td>
</tr>
<tr>
<td>62</td>
<td>NX</td>
<td>RW</td>
<td>页表项的不可执行位（NX）。</td>
</tr>
<tr>
<td>61</td>
<td>NR</td>
<td>RW</td>
<td>页表项的不可读位（NR）。</td>
</tr>
<tr>
<td>60:PALEN</td>
<td>0</td>
<td>R0</td>
<td>保留域。读返回 0。</td>
</tr>
<tr>
<td>PALEN-1:log<code>2</code>PageSize</td>
<td>PPN</td>
<td>RW</td>
<td>页表的物理页号（PPN）。</td>
</tr>
<tr>
<td>log<code>2</code>PageSize-1:13</td>
<td>R0</td>
<td>R0</td>
<td>保留域。读返回 0。</td>
</tr>
<tr>
<td>12</td>
<td>G</td>
<td>RW</td>
<td>页表项的全局标志位（G）。</td>
</tr>
<tr>
<td>11:9</td>
<td>0</td>
<td>R0</td>
<td>保留域。读返回 0。</td>
</tr>
<tr>
<td>8</td>
<td>W</td>
<td>RW</td>
<td>对应的物理页是否可写。</td>
</tr>
<tr>
<td>7</td>
<td>P</td>
<td>RW</td>
<td>物理页是否存在。</td>
</tr>
<tr>
<td>6</td>
<td>H</td>
<td>RW</td>
<td>为 1 表示此时的目录项实际上存放了一个大页的页表项信息。</td>
</tr>
<tr>
<td>5:4</td>
<td>MAT</td>
<td>RW</td>
<td>页表项的存储访问类型（MAT）。</td>
</tr>
<tr>
<td>3:2</td>
<td>PLV</td>
<td>RW</td>
<td>页表项的特权等级（PLV）。</td>
</tr>
<tr>
<td>1</td>
<td>D</td>
<td>RW</td>
<td>页表项的脏位（D）。</td>
</tr>
<tr>
<td>0</td>
<td>V</td>
<td>RW</td>
<td>页表项的有效位（V）。</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>按照上面的定义：
- 当<code class="docutils literal notranslate"><span class="pre">PageSize=2MB</span></code>页时，大页页表PageTable[PALEN-1: 21]是PPN[PALEN-1:21], PPN[20:0] = VA[20:0]
PA = {PageTable[PALEN-1: 21], VA[20:0]}.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>- 当``PageSize=1G``页时，大页页表PageTable[PALEN-1: 30]是PPN[PALEN-1:30], PPN[29:0] = VA[29:0]
  PA = {PageTable[PALEN-1: 30], VA[29:0]}.

- 当``PageSize=512G``页时，大页页表PageTable[PALEN-1: 39]是PPN[PALEN-1:39], PPN[38:0] = VA[38:0]
  PA = {PageTable[PALEN-1: 39], VA[38:0]}.

- 当``PageSize=32MB``页时，大页页表PageTable[PALEN-1: 25]是PPN[PALEN-1:25], PPN[24:0] = VA[24:0]
  PA = {PageTable[PALEN-1: 25], VA[24:0]}. 

- 当``PageSize=64G``页时，大页页表PageTable[PALEN-1: 36]是PPN[PALEN-1:36], PPN[35:0] = VA[35:0]
  PA = {PageTable[PALEN-1: 36], VA[35:0]}. 
</pre></div>
</div>
</div>
</section>
<section id="no-leaf-pg-entry">
<span id="id16"></span><h3><span class="section-number">4.5.3.3. </span>中间指向下一级目录的地址的页表(非叶子节点页表)<a class="headerlink" href="#no-leaf-pg-entry" title="Link to this heading"></a></h3>
<a class="bg-primary reference internal image-reference" href="../../_images/loongarch-multi-level-page-note-4k.png"><img alt="LoongArch Base Page Table" class="bg-primary align-center" src="../../_images/loongarch-multi-level-page-note-4k.png" style="width: 865.5px; height: 618.75px;" /></a>
<p><strong>非叶子节点页表</strong>也就是执行下一级页表基址的页表，如上图（<strong>中间节点</strong>）所示，其具体的定义如下：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>63:PALEN</td>
<td>0</td>
<td>R0</td>
<td>保留域。读返回 0。</td>
</tr>
<tr>
<td>PALEN-1:12</td>
<td>PPN</td>
<td>RW</td>
<td>页表的物理页号（PPN）。</td>
</tr>
<tr>
<td>11:0</td>
<td>0</td>
<td>R0</td>
<td>如果下一级页表的基址不是按照页对齐的，会发生错误！</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>有时候kernel在写入地址非叶子节点时，一般是物理地址，有时也会可能写入虚拟地址，但是这个虚拟地址很特殊，<br />
比如我们的物理地址为0x80000，虚拟地址为0x9000000000080000，此时写入非叶子节点也是可以的！</p>
<p>底层的实现逻辑如下：</p>
<p>实际读取的下一级的地址 = 非叶子节点页表[63：0] &amp; ((1 &lt;&lt; (PALEN + 1)) - 1)</p>
</div>
<div class="admonition caution">
<p class="admonition-title">小心</p>
<p>如果叶子节点的[11:0]不等于0，则会被识别为一个大页的页表项！，因此需要特别注意，后面章节我们会用例子说明！</p>
</div>
</section>
</section>
<section id="id17">
<h2><span class="section-number">4.5.4. </span>页表的遍历<a class="headerlink" href="#id17" title="Link to this heading"></a></h2>
<section id="k">
<h3><span class="section-number">4.5.4.1. </span>以一个例子4K页为例说明：<a class="headerlink" href="#k" title="Link to this heading"></a></h3>
<a class="bg-primary reference internal image-reference" href="../../_images/loongarch-multi-level-page-note-4k.png"><img alt="LoongArch Base Page Table" class="bg-primary align-center" src="../../_images/loongarch-multi-level-page-note-4k.png" style="width: 865.5px; height: 618.75px;" /></a>
<hr class="docutils" />
<p>假设我们现在访问虚拟地址<strong>0xFFFF_FF80_0000_9200</strong>，下面我们以<strong>4K页，三级页表</strong>为例，详细说明它的遍历过程。</p>
<p><code class="docutils literal notranslate"><span class="pre">PWCL和PWCH寄存器设置如下（可以是下面的配置）：</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Dir4_base  = 0
Dir4_width = 0

Dir3_base  = 0
Dir3_width = 0

// VPN宽度9，起始地址为30 
Dir2_base  = 0x1e
Dir2_width = 0x9

// VPN宽度9，起始地址为21 
Dir1_base  = 0x15（或者十进制21）
Dir1_width = 0x9  (十进制9)

// VPN宽度9，起始地址为12 
PTbase  = 0xc （或者十进制12）
PTwidth = 0x9  (十进制9)

// 页表表项64-bit
PTEWidth = 0
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CSR.PWCH</span> <span class="pre">=</span> <span class="pre">0x0，</span> <span class="pre">CSR.PWCL</span> <span class="pre">=</span> <span class="pre">0x13e4d52c</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PTESIZE</span> <span class="o">=</span> <span class="mi">8</span> <span class="p">(</span><span class="mi">64</span><span class="o">-</span><span class="n">bit</span><span class="p">,</span> <span class="mi">8</span> <span class="n">Bytes</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p><strong>步骤1</strong>：
首先，我们会按照虚拟地址的最高位VA[63]位，选择页表的基址（也成为PGD基址）。</p>
<ul class="simple">
<li><p>如果VA[63] = 1，则选择CSR.PGDH作为PGD查找。</p></li>
<li><p>如果VA[63] = 0，则选择CSR.PGDL作为PGD查找。<br />
本例子中，会选择CSR.PGDH作为PGD查找。</p></li>
</ul>
<p>通常情况下，我们将CSR.PGDH作为用户空间的全局页表基址，将CSR.PGDH作为内核空间的全局页表基址。
在进程切换和创建的时候，所有的进程共用CSR.PGDH，而新创建进场的都有各自的CSR.PGDL；切成切换时，
也要切换CSR.PGDL。</p>
<p><code class="docutils literal notranslate"><span class="pre">pgd_dir_base</span> <span class="pre">=</span> <span class="pre">CSR.PGDH</span></code></p>
</li>
<li><p><strong>步骤2</strong>
此时，三级页表的索引址按照下面计算:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LEVE_3_INDEX</span> <span class="o">=</span> <span class="p">(</span><span class="n">VA</span><span class="p">[</span><span class="mi">63</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> 

<span class="n">pgd_base</span> <span class="o">=</span> <span class="n">pgd_dir_base</span> <span class="o">+</span> <span class="n">LEVE_3_INDEX</span> <span class="o">*</span> <span class="n">PTESIZE</span>
</pre></div>
</div>
<p>然后读取 PGD的值</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PGD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">pgd_base</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p><strong>步骤3</strong>
判断 PMD的有效性，按照我们上面的<a class="reference internal" href="#no-leaf-pg-entry"><u>章节</u></a>描述。</p>
<ul class="simple">
<li><p>如何是正常的非叶子节点页表，也就是执行下一级页表的基址，此时执行下一步骤4。</p></li>
<li><p>如果判断是大页的话，则进入大页判断的步骤。我们在下一个小节会说明。</p></li>
</ul>
</li>
<li><p><strong>步骤4</strong>
此时进行二级页表的判断。二级页表的索引址按照下面计算:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LEVE_2_INDEX</span> <span class="o">=</span> <span class="p">(</span><span class="n">VA</span><span class="p">[</span><span class="mi">63</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">21</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> 

<span class="n">pmd_base</span> <span class="o">=</span> <span class="n">PUD</span> <span class="o">+</span> <span class="n">LEVE_2_INDEX</span> <span class="o">*</span> <span class="n">PTESIZE</span>
</pre></div>
</div>
<p>然后读取 PMD的值</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PMD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">pmd_base</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p><strong>步骤5</strong>
此时进行<strong>步骤3</strong>的判断，如果是正常页，则继续下一步骤的计算。</p></li>
<li><p><strong>步骤6</strong>
此时进行最后一级页表的判断。最后一级页表的索引址按照下面计算:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LEVE_1_INDEX</span> <span class="o">=</span> <span class="p">(</span><span class="n">VA</span><span class="p">[</span><span class="mi">63</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">12</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> 

<span class="n">pte_base</span> <span class="o">=</span> <span class="n">PMD</span> <span class="o">+</span> <span class="n">LEVE_1_INDEX</span> <span class="o">*</span> <span class="n">PTESIZE</span>
</pre></div>
</div>
<p>然后读取 PTE的值</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PTE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">pte_base</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p><strong>步骤7</strong>
此时按照正常页表来处理。</p>
<p>如果PTE.V=0 则执行page_fault异常，具体的分取指，还是Load指令，还是Store指令。</p>
<p>详细的异常可参考<a class="reference internal" href="tlb_struct.html#tlb-excption-handle"><span class="std std-ref"><u>章节TLB所有异常描述</u></span></a>中的说明，<br />
还有参考<a class="reference internal" href="tlb_struct.html#cpu-inner-tlb-lookup"><span class="std std-ref"><u>章节CPU是如何查找页表的</u></span></a>中伪代码的说明。</p>
<p>如果所有的检查通过，则执行下一个步骤，否则抛出异常！</p>
</li>
<li><p><strong>步骤8</strong></p>
<p>获得物理地址<code class="docutils literal notranslate"><span class="pre">PA[PALEN-1:0]</span> <span class="pre">=</span> <span class="pre">{PTE.PPN,</span> <span class="pre">VA[11:0]}</span></code><br />
或者是<code class="docutils literal notranslate"><span class="pre">PA[PALEN-1:0]</span> <span class="pre">=</span> <span class="pre">{PTE[PALEN-1:</span> <span class="pre">12],</span> <span class="pre">VA[11:0]}</span></code></p>
</li>
</ul>
</section>
<section id="m">
<h3><span class="section-number">4.5.4.2. </span>以一个例子2M页为例说明：<a class="headerlink" href="#m" title="Link to this heading"></a></h3>
<a class="bg-primary reference internal image-reference" href="../../_images/loongarch-multi-level-page-note-2M.png"><img alt="LoongArch Base Page Table" class="bg-primary align-center" src="../../_images/loongarch-multi-level-page-note-2M.png" style="width: 865.5px; height: 618.75px;" /></a>
<hr class="docutils" />
<p>假设我们现在访问虚拟地址<strong>0xFFFF_FF80_0000_9200</strong>，下面我们以<strong>4K页，三级页表</strong>为例，详细说明它的遍历过程。</p>
<p><code class="docutils literal notranslate"><span class="pre">PWCL和PWCH寄存器设置如下（可以是下面的配置）：</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Dir4_base  = 0
Dir4_width = 0

Dir3_base  = 0
Dir3_width = 0

// VPN宽度9，起始地址为30 
Dir2_base  = 0x1e
Dir2_width = 0x9

// VPN宽度9，起始地址为21 
Dir1_base  = 0x15（或者十进制21）
Dir1_width = 0x9  (十进制9)

// VPN宽度9，起始地址为12 
PTbase  = 0xc （或者十进制12）
PTwidth = 0x9  (十进制9)

// 页表表项64-bit
PTEWidth = 0
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CSR.PWCH</span> <span class="pre">=</span> <span class="pre">0x0，</span> <span class="pre">CSR.PWCL</span> <span class="pre">=</span> <span class="pre">0x13e4d52c</span></code></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">PTESIZE</span> <span class="o">=</span> <span class="mi">8</span> <span class="p">(</span><span class="mi">64</span><span class="o">-</span><span class="n">bit</span><span class="p">,</span> <span class="mi">8</span> <span class="n">Bytes</span><span class="p">)</span>
</pre></div>
</div>
<ul>
<li><p><strong>步骤1</strong>：
首先，我们会按照虚拟地址的最高位VA[63]位，选择页表的基址（也成为PGD基址）。</p>
<ul class="simple">
<li><p>如果VA[63] = 1，则选择CSR.PGDH作为PGD查找。</p></li>
<li><p>如果VA[63] = 0，则选择CSR.PGDL作为PGD查找。<br />
本例子中，会选择CSR.PGDH作为PGD查找。</p></li>
</ul>
<p>通常情况下，我们将CSR.PGDH作为用户空间的全局页表基址，将CSR.PGDH作为内核空间的全局页表基址。
在进程切换和创建的时候，所有的进程共用CSR.PGDH，而新创建进场的都有各自的CSR.PGDL；切成切换时，
也要切换CSR.PGDL。</p>
<p><code class="docutils literal notranslate"><span class="pre">pgd_dir_base</span> <span class="pre">=</span> <span class="pre">CSR.PGDH</span></code></p>
</li>
<li><p><strong>步骤2</strong>
此时，三级页表的索引址按照下面计算:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LEVE_3_INDEX</span> <span class="o">=</span> <span class="p">(</span><span class="n">VA</span><span class="p">[</span><span class="mi">63</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> 

<span class="n">pgd_base</span> <span class="o">=</span> <span class="n">pgd_dir_base</span> <span class="o">+</span> <span class="n">LEVE_3_INDEX</span> <span class="o">*</span> <span class="n">PTESIZE</span>
</pre></div>
</div>
<p>然后读取 PGD的值</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PGD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">pgd_base</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p><strong>步骤3</strong>
判断 PMD的有效性，按照我们上面的<a class="reference internal" href="#no-leaf-pg-entry"><u>章节</u></a>描述。</p>
<ul class="simple">
<li><p>如何是正常的非叶子节点页表，也就是执行下一级页表的基址，此时执行下一步骤4。</p></li>
<li><p>如果判断是大页的话，则进入大页判断的步骤。此时的大页大小为1GB。</p></li>
</ul>
</li>
<li><p><strong>步骤4</strong>
此时进行二级页表的判断。二级页表的索引址按照下面计算:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">LEVE_2_INDEX</span> <span class="o">=</span> <span class="p">(</span><span class="n">VA</span><span class="p">[</span><span class="mi">63</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">21</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> 

<span class="n">pmd_base</span> <span class="o">=</span> <span class="n">PUD</span> <span class="o">+</span> <span class="n">LEVE_2_INDEX</span> <span class="o">*</span> <span class="n">PTESIZE</span>
</pre></div>
</div>
<p>然后读取 PMD的值</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PMD</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="p">((</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">pmd_base</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p><strong>步骤5</strong></p>
<ul class="simple">
<li><p>此时进行<strong>步骤3</strong>的判断，如果是正常页，则按照上面的章节步骤执行。<br />
本次例子是2M的页大小。</p></li>
<li><p>发现此时PMD[11:0] ！= 0，则发现是大页，此时的大页大小为2MB</p></li>
</ul>
</li>
<li><p><strong>步骤6</strong>
此时判断页表的各个属性值是否匹配。</p>
<p>如果PTE.V=0 则执行page_fault异常，具体的分取指，还是Load指令，还是Store指令。</p>
<p>详细的异常可参考<a class="reference internal" href="tlb_struct.html#tlb-excption-handle"><span class="std std-ref"><u>章节TLB所有异常描述</u></span></a>中的说明，<br />
还有参考<a class="reference internal" href="tlb_struct.html#cpu-inner-tlb-lookup"><span class="std std-ref"><u>章节CPU是如何查找页表的</u></span></a>中伪代码的说明。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>注意此时的页表是大页，而大页的BIG_PTE[12]保存着G标志，也就是全局页表标志位。而BIG_PTE[6]为1，<br />
表明此页是个大页，而不是全局标志。<strong>这里和基本页表不一致，需要注意!</strong></p>
</div>
<p>如果所有的检查通过，则执行下一个步骤，否则抛出异常！</p>
</li>
<li><p><strong>步骤7</strong></p>
<p>获得物理地址<code class="docutils literal notranslate"><span class="pre">PA[PALEN-1:0]</span> <span class="pre">=</span> <span class="pre">{PTE.PPN,</span> <span class="pre">VA[20:0]}</span></code><br />
或者是<code class="docutils literal notranslate"><span class="pre">PA[PALEN-1:0]</span> <span class="pre">=</span> <span class="pre">{PTE[PALEN-1:</span> <span class="pre">21],</span> <span class="pre">VA[20:0]}</span></code></p>
</li>
</ul>
</section>
</section>
</section>
<section id="cputlb">
<h1><span class="section-number">4.6. </span>从内存中的页表表项到CPU中的TLB<a class="headerlink" href="#cputlb" title="Link to this heading"></a></h1>
<p>上面章节的<strong>页表的遍历</strong>是以<strong>内核的角度</strong>来指定的硬件应该支持的<code class="docutils literal notranslate"><span class="pre">给出虚拟地址找到物理地址的过程</span></code>。</p>
<p>实际在转换的过程中，我们为了加速这一过程，在CPU的内部设立了一个加速的部件，我们称之为<strong>TLB</strong>。</p>
<p><strong>TLB中保存着内存中页表表项的一个副本！</strong></p>
<p>CPU如何在TLB中找到虚实转换，按照我们<a class="reference internal" href="tlb_struct.html#cpu-inner-tlb-lookup"><span class="std std-ref"><u>章节CPU是如何在TLB中查找页表的</u></span></a>中伪代码的说明。</p>
<p>而CPU如何将内存中的页表表项拿到TLB中，也就是页表遍历我们有两种实现的方法：</p>
<ul class="simple">
<li><p>一种是使用软件模拟上述遍历的方式，我们称为TLBRefill，即TLB重填。</p></li>
<li><p>另一种是使用硬件，自动的执行上面的步骤，我们称为HPTW，即Hardware PageTable Walk。</p></li>
</ul>
<section id="tlbrefill-softeware-ptw">
<h2><span class="section-number">4.6.1. </span>TLBRefill (Softeware PTW)<a class="headerlink" href="#tlbrefill-softeware-ptw" title="Link to this heading"></a></h2>
<p>根据上面的描述，TLB重填就是将内存中的页表表项加载到CPU中的TLB中。下面介绍LoongArch的重填相关内容。</p>
<section id="csr">
<h3><span class="section-number">4.6.1.1. </span>相关的CSR寄存器<a class="headerlink" href="#csr" title="Link to this heading"></a></h3>
<p>所使用的csr寄存器，以及相关的示例代码</p>
<p>主要用于软件TLB重填。
<strong>包括</strong>：</p>
<ul class="simple">
<li><p>❖TLBRENTRY：TLB 重填例外入口地址，该寄存器用于配置 TLB 重填例外的入口地址。由于触发 TLB 重填例外之后，<br />
处理器核<strong>将进入直接地址翻译模式</strong>，所以此处所填<strong>入口地址应当是物理地址</strong>。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>11:0</td>
<td>0</td>
<td>R</td>
<td>TLB 重填例外入口地址[11:0]位。只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>PALEN-1:12</td>
<td>PPN</td>
<td>RW</td>
<td>TLB 重填例外入口地址[PALEN-1:12]位。此处填入的地址应为物理地址。</td>
</tr>
<tr>
<td>63:PALEN</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖TLBRERA：TLB 重填例外返回地址，该寄存器保存 TLB 重填例外处理完毕之后的返回地址。除此之外，<br />
该寄存器还包含用于标识当前例外是 TLB 重填例外的标志位。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>IsTLBR</td>
<td>RW</td>
<td>该位为 1 表示当前处于 TLB 重填例外处理的上下文中。<br>当触发 TLB 重填例外时，硬件将该位置 1。<br>当该位为 1 时，仅在 CSR.ERRCTL.IsMERR=0 的情况下，执行 ERTN 指令会将其清 0，<br>否则保持不变。<br>因为架构中为 TLB 重填例外定义了一套独立的 CSR，所以当该位为 1 时，<br>ERTN 返回时，用于恢复 CSR.CRMD 的信息将来自于 CSR.TLBRPRMD；<br>ERTN 返回地址信息将来自于 CSR.TLBRERA；<br>TLBWR 和 TLBFILL 指 令 待 写 入 的 表 项 信 息 将 来 自 于 CSR.TLBREHI 、<br>CSR.TLBELO0、CSR.TLBELO1；<br>TLBSRCH 指令查询的信息来自于 CSR.TLBREHI；<br>LDDIR、LDPTE 指令执行所需的出错虚地址信息将来自于 CSR.TLBRBADV。</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>GRLEN-1:2</td>
<td>PC</td>
<td>RW</td>
<td>记录触发 TLB 重填例外的指令的 PC 的[GRLEN-1:2]位。当执行 ERTN 指令从 TLB 重填<br>例外处理程序返回时（此时本寄存器 IsTLBR=1 且 CSR.ERRCTL.IsMERR=0），硬件自<br>动将存放在此处的值最低位补上两比特 0 后作为最终的返回地址。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖TLBRBADV：TLB 重填例外出错虚地址，该寄存器用于记录触发 TLB 重填例外的出错虚地址。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GRLEN-1:0</td>
<td>VAddr</td>
<td>RW</td>
<td>当触发 TLB 重填例外时，硬件将出错的虚地址记录与此。对于 LA64 架构，<br>在这种情况下，如果触发例外的特权等级处于 32 位地址模式，<br>那么记录的虚地址的高 32 位强制置为 0。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖TLBREHI：TLB 重填例外表项高位，TLBREHI 寄存器是处于 TLB 重填例外上下文时（此时 CSR.TLBRERA.IsTLBR=1），存放 TLB<br />
指令操作时 TLB 表项低位部分物理页号等相关的信息。TLBREHI 寄存器的格式及各个域的含义分别与 TLBEHI寄存器一样</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>5:0</td>
<td>PS</td>
<td>RW</td>
<td>TLB 重填例外专用的页大小值。即在 CSR.TLBRERA.IsTLBR=1 时，执行 TLBWR<br> 和TLBFILL 指令，写入的 TLB 表项的 PS 域的值来自于此。</td>
</tr>
<tr>
<td>12:6</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>VALEN-1:13</td>
<td>VPPN</td>
<td>RW</td>
<td>在 CSR.TLBRERA.IsTLBR=1 时，执行 TLBSRCH 指令时查询 TLB 所用 VPPN 值，<br>以及执行 TLBWR 和 TLBFILL 指令时写入 TLB 表项的 VPPN 域的值来自于此。<br>当触发 TLB 重填例外时，触发例外的虚地址的[VALEN-1:13]位被记录到这里。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖TLBRELO0： TLB 重填例外表项低位0</p></li>
<li><p>❖TLBRELO1： TLB 重填例外表项低位1</p></li>
</ul>
<p>TLBRELO0/1 两寄存器是处于 TLB 重填例外上下文时（此时 CSR.TLBRERA.IsTLBR=1），存放 TLB<br />
指令操作时 TLB 表项低位部分物理页号等相关的信息。TLBRELO0/1 两寄存器的格式及各个域的含义分别<br />
与 TLBELO0/1 两寄存器一样。</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>V</td>
<td>RW</td>
<td>页表项的有效位（V）。</td>
</tr>
<tr>
<td>1</td>
<td>D</td>
<td>RW</td>
<td>页表项的脏位（D）。</td>
</tr>
<tr>
<td>3:2</td>
<td>PLV</td>
<td>RW</td>
<td>页表项的特权等级（PLV）。</td>
</tr>
<tr>
<td>5:4</td>
<td>MAT</td>
<td>RW</td>
<td>页表项的存储访问类型（MAT）。</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>RW</td>
<td>页表项的全局标志位（G）。执行 TLBFILL 和 TLBWR 指令时，仅当 TLBELO0 和 TLBELO1 中的 G 位均为 1 时，<br>填入到 TLB 中的页表项的 G 位才为 1。</td>
</tr>
<tr>
<td>11:7</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>PALEN-1:12</td>
<td>PPN</td>
<td>RW</td>
<td>页表的物理页号（PPN）。</td>
</tr>
<tr>
<td>60:PALEN</td>
<td>0</td>
<td>R</td>
<td>只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>61</td>
<td>NR</td>
<td>RW</td>
<td>页表项的不可读位（NR）。</td>
</tr>
<tr>
<td>62</td>
<td>NX</td>
<td>RW</td>
<td>页表项的不可执行位（NX）。</td>
</tr>
<tr>
<td>63</td>
<td>RPLV</td>
<td>RW</td>
<td>页表的受限特权等级使能（RPLV）。当 RPLV=0 时，该页表项可以被任何特权等级<br>不低于 PLV 的程序访问；当 RPLV=1 时，该页表项仅<br>可以被特权等级等于 PLV 的程序访问。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖TLBRPRMD：TLB 重填例外前模式信息，当触发 TLB 重填例外时，硬件会将此时处理器核的特权等级、<br />
客户机模式、全局中断使能和监视点使能位保存至该寄存器中，用于例外返回时恢复处理器核的现场。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1:0</td>
<td>PPLV</td>
<td>RW</td>
<td>当触发 TLB 重填例外时，硬件会将 CSR.CRMD 中 PLV 域的旧值记录在这个域。<br>当 CSR.TLBRERA.IsTLBR=1 时，执行 ERTN 指令从例外处理程序返回时，硬件会将这个域的值恢复到 <br>CSR.CRMD 的 PLV 域。</td>
</tr>
<tr>
<td>2</td>
<td>PIE</td>
<td>RW</td>
<td>当触发 TLB 重填例外时，硬件会将 CSR.CRMD 中 IE 域的旧值记录在这个域。<br>当 CSR.TLBRERA.IsTLBR=1 时，执行 ERTN 指令从例外处理程序返回时，<br>硬件会将这个域的值恢复到 CSR.CRMD 的 IE 域。</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>R</td>
<td>若未实现虚拟化扩展，则该位只读恒为 0，写被忽略。</td>
</tr>
<tr>
<td>4</td>
<td>PWE</td>
<td>RW</td>
<td>当触发 TLB 重填例外时，硬件会将 CSR.CRMD 中 WE 域的旧值记录在这个域。<br>当 CSR.TLBRERA.IsTLBR=1 时，执行 ERTN 指令从例外处理程序返回时，硬件会将这<br>个域的值恢复到 CSR.CRMD 的 WE 域。</td>
</tr>
<tr>
<td>31:5</td>
<td>0</td>
<td>R0</td>
<td>保留域。读返回 0，且软件不允许改变其值。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<ul class="simple">
<li><p>❖TLBRSAVE：TLB 重填例外数据保存，该寄存器用于给系统软件暂存数据。每个数据保存寄存器可以存放一个通用寄存器的数据。<br />
之所以额外设置一个供 TLB 重填例外处理程序使用的 SAVE 寄存器，是针对非 TLB 重填例外的处理过<br />
程中触发 TLB 重填例外这一情况。</p></li>
</ul>
<table border="1" class="docutils">
<thead>
<tr>
<th>位</th>
<th>名字</th>
<th>读写</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GRLEN-1:0</td>
<td>Data</td>
<td>RW</td>
<td>仅供软件读写的数据。除执行 CSR 指令外，硬件不会修改该域的内容。</td>
</tr>
</tbody>
</table>
<hr class="docutils" />
<div class="admonition tip">
<p class="admonition-title">小技巧</p>
<p>假设如下代码段需要充填TLB：</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="w">	</span><span class="nf">ld.d</span><span class="w">  </span><span class="no">$a0</span><span class="p">,</span><span class="w"> </span><span class="no">$sp</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span>
</pre></div>
</div>
<p>此时，如果发生了TLB重填，会产生一个异常，我们称为重填异常，它有自己独立的入口（因为TLB重填异常发生的频率很高，因此为了提高
性能，专门设立了一个重填入口）保存在CSR.TLBRENTRY寄存器中。见上面的表述。</p>
<p>此时，产生TLB异常的PC保存在CSR.TLBRERA中。而访问内存的地址<code class="docutils literal notranslate"><span class="pre">$sp</span></code>的值，则保存在了CSR.RBADV中。</p>
</div>
</section>
<section id="id18">
<h3><span class="section-number">4.6.1.2. </span>重填示例代码<a class="headerlink" href="#id18" title="Link to this heading"></a></h3>
<p>我们以一个具体的例子，来说明软件重填的过程，和需要的指令是什么。如下：</p>
<p id="example-pwclh-tlb-refill">假设PWCL和PWCH状态控制寄存器的值为：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Dir4_base  = 0
Dir4_width = 0

// VPN宽度9，起始地址为30 
Dir3_base  = 0x1e // 30
Dir3_width = 0x9

Dir2_base  = 0x0
Dir2_width = 0x0

// VPN宽度9，起始地址为21 
Dir1_base  = 0x15（或者十进制21）
Dir1_width = 0x9  (十进制9)

// VPN宽度9，起始地址为12 
PTbase  = 0xc （或者十进制12）
PTwidth = 0x9  (十进制9)

// 页表表项64-bit
PTEWidth = 0
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">CSR.PWCH</span> <span class="pre">=</span> <span class="pre">0x25e，</span> <span class="pre">CSR.PWCL</span> <span class="pre">=</span> <span class="pre">0x4d52c</span></code></p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="cm">/* TLB Refill registers */</span>
<span class="c1">#define LOONGARCH_CSR_TLBRENTRY		0x88	/* TLB refill exception entry */</span>
<span class="c1">#define LOONGARCH_CSR_TLBRBADV		0x89	/* TLB refill badvaddr */</span>
<span class="c1">#define LOONGARCH_CSR_TLBRERA		0x8a	/* TLB refill ERA */</span>
<span class="c1">#define LOONGARCH_CSR_TLBRSAVE		0x8b	/* KSave for TLB refill exception */ </span>
<span class="c1">#define LOONGARCH_CSR_PGD		    0x1b	/* Page table base */</span>


<span class="nl">handle_tlb_refill:</span>
<span class="w">	</span><span class="nf">csrwr</span><span class="w">		</span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="no">LOONGARCH_CSR_TLBRSAVE</span>
<span class="w">	</span><span class="nf">csrrd</span><span class="w">		</span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="no">LOONGARCH_CSR_PGD</span>
<span class="w">	</span><span class="nf">lddir</span><span class="w">		</span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span>
<span class="w">	</span><span class="nf">lddir</span><span class="w">		</span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">	</span><span class="nf">ldpte</span><span class="w">		</span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span>
<span class="w">	</span><span class="nf">ldpte</span><span class="w">		</span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">	</span><span class="nf">tlbfill</span>
<span class="w">	</span><span class="nf">csrrd</span><span class="w">		</span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="no">LOONGARCH_CSR_TLBRSAVE</span>
<span class="w">	</span><span class="nf">ertn</span>
</pre></div>
</div>
<p>此时，假设我们运行在用户态，也就是PLV = PLV3，内核态的PLV = PLV0；</p>
<p>首先进入异常入口执行handle_tlb_refill的第一条指令。</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">csrwr</span><span class="w">		</span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="no">LOONGARCH_CSR_TLBRSAVE</span>
</pre></div>
</div>
<p>上述的目的是为了保存当前重填历程中使用到的寄存器，比如<code class="docutils literal notranslate"><span class="pre">$t0</span></code></p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><strong>LDDIR 指令</strong></p>
<p>LDDIR 指令用于在软件页表遍历过程中目录项的访问。</p>
<p>指令格式： <code class="docutils literal notranslate"><span class="pre">lddir</span> <span class="pre">rd,</span> <span class="pre">rj,</span> <span class="pre">level</span></code></p>
<p>LDDIR 指令中的 8 比特立即数 level 用于指示当前访问的是哪一级页表。level=1 对应 CSR.PWCL 中的<br />
PT，level=2 对应 CSR.PWCL 中的 Dir1，level=3 对应 CSR.PWCL 中的 Dir2，level=4 对应 CSR.PWCH 中的<br />
Dir3。</p>
<p>如果通用寄存器 rj 的第[14:13]位不等于 0，表明此时通用寄存器 rj 的值是一个已标记页表大小信息的<br />
大页（HugePage）页表项。此情况下将通用寄存器 rj 中的值直接写入到通用寄存器 rd 中。</p>
<p>如果通用寄存器 rj 的第[14:13]位等于 0 且它的第[6]位是 1，表明此时通用寄存器 rj 的值是一个尚未标<br />
记页表大小信息的一个大页（HugePage）的页表项。此情况下将通用寄存器 rj 值的[14:13]位替换为 level[1:0]<br />
后，整体写入到通用寄存器 rd 中。</p>
<p>如果通用寄存器 rj 的第[14:13]位等于 0 且它的第[6]位是 0，表明此时通用寄存器 rj 的值是第 level 级页<br />
表的基址的物理地址。此情况下执行 LDDIR 指令，会根据当前处理的 TLB 重填地址访问第 level 级页表，<br />
取回下一级页表的基址，写入到通用寄存器 rd 中。注意，第 level 级页表的下一级页表并不限于第 level-1 级<br />
页表。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><strong>LDPTE 指令</strong></p>
<p>LDPTE 指令用于在软件页表遍历过程中页表项的访问。</p>
<p>指令格式： <code class="docutils literal notranslate"><span class="pre">ldpte</span> <span class="pre">rj,</span> <span class="pre">seq</span></code></p>
<p>LDPTE 指令中的立即数seq用于指示访问的偶数页还是奇数页。 访问偶数页时结果将被写入<br />
CSR.TLBRELO0，访问奇数页时结果将被写入 CSR.TLBRELO1。</p>
<p>如果通用寄存器 rj 的第[6]位是 0，表明此时 rj 中的内容是 PTE 那一级页表的基址的物理地址。这种情<br />
况下执行 LDPTE 指令，会根据当前处理的 TLB 重填地址访问 PTE 级页表，取回页表项将其写入到对应的<br />
CSR 中。</p>
<p>如果通用寄存器 rj 的第[6]位是 1，表明此时 rj 中的内容是一个大页（HugePage）页表项。此情况下，<br />
通用寄存器 rj 值的[14:13]位应为一非零值 n，标识它是一个对应第 n 级页表的大页表项。将通用寄存器 rj<br />
中的值转换成最终的页表项格式后写入到对应的 CSR 中。</p>
</div>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">csrrd</span><span class="w">		</span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="no">LOONGARCH_CSR_PGD</span>
</pre></div>
</div>
<p>读取全局页表基址，具体的内容可查看<a class="reference internal" href="tlb_struct.html#csr-pgd-ctx"><span class="std std-ref"><u>PGD/PGDH/PGDL的具体定义和使用规则</u></span></a>。</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">lddir</span><span class="w">		</span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="c1">// 注意这里的3</span>
</pre></div>
</div>
<p>按照我们之前的<a class="reference internal" href="#example-pwclh-tlb-refill"><u>PWCH的设置</u></a>，我们设置了<code class="docutils literal notranslate"><span class="pre">Dir3_Base和Dir3_width</span></code></p>
<div class="admonition caution">
<p class="admonition-title">小心</p>
<p><strong>lddir指令后面的Level，一定要和初始化PWCL和PWCH寄存器的要匹配，如果不匹配会出现错误！！！</strong></p>
</div>
<p>此时$t0保存的是pgd的值，也就是下一级pmd的基址。</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">lddir</span><span class="w">		</span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="c1">// 注意这里的1</span>
</pre></div>
</div>
<p>按照我们之前的<a class="reference internal" href="#example-pwclh-tlb-refill"><u>PWCH的设置</u></a>，我们设置了<code class="docutils literal notranslate"><span class="pre">Dir1_Base和Dir1_width</span></code></p>
<p>此时$t0保存的是pmd的值，也就是下一级pte的基址。</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">ldpte</span><span class="w">		</span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span>
</pre></div>
</div>
<p>以<code class="docutils literal notranslate"><span class="pre">$t0</span></code>为基址，读取PTE的值，然后存放到CSR.TLBELO0的偶数页寄存器中。</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">ldpte</span><span class="w">		</span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
<p>以<code class="docutils literal notranslate"><span class="pre">$t0</span> <span class="pre">+</span> <span class="pre">8</span></code>为基址，读取PTE的值，然后存放到CSR.TLBELO1的奇数页寄存器中。</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">tlbfill</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><strong>tlbfill 指令</strong></p>
<p>TLBFILL 指令将 TLB 相关 CSR 中所存放的页表项信息填入到 TLB 中。被填入的页表项信息来自于<br />
CSR.TLBEHI、CSR.TLBELO0、CSR.TLBELO1 和 CSR.TLBIDX.PS。若此时 CSR.TLBRERA.IsTLBR=1，即<br />
处于 TLB 重填例外处理过程中，那么 TLB 中总是填入一个有效项（即 TLB 项的 E 位为 1）。否则的话，就<br />
需要看 CSR.TLBIDX.NE 位的值。此时如果 CSR.TLBIDX.NE=1，那么 TLB 中会被填入一个无效 TLB 项；<br />
仅当 CSR.TLBIDX.NE=0 时，TLB 中才会被填入一个有效 TLB 项。</p>
</div>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">csrrd</span><span class="w">		</span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="no">LOONGARCH_CSR_TLBRSAVE</span>
</pre></div>
</div>
<p>将保存在CSR.TLBRSAVE中的值，恢复到$t0寄存器中，然后返回！。</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">ertn</span>
</pre></div>
</div>
<p>ertn将判断当前处于TLBRefill历程中，然后将跳转到CSR.TLBRERA保存的地方开始执行。 并且恢复其各个状态！</p>
</section>
<section id="id19">
<h3><span class="section-number">4.6.1.3. </span>两级页表的示例代码<a class="headerlink" href="#id19" title="Link to this heading"></a></h3>
<p>下面是两级的PWCH和PWCL的配置，不区分是4K页还是16K页，我们给出的是4KB页配置。</p>
<p><code class="docutils literal notranslate"><span class="pre">PWCH:</span> <span class="pre">0x255,</span> <span class="pre">PWCL:</span> <span class="pre">0x12c</span></code></p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">SYM_CODE_START</span><span class="p">(</span><span class="no">handle_tlb_refill</span><span class="p">)</span>
<span class="w">	</span><span class="nf">csrwr</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="no">LOONGARCH_CSR_TLBRSAVE</span>
<span class="w">	</span><span class="nf">csrrd</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="no">LOONGARCH_CSR_PGD</span>
<span class="w">	</span><span class="nf">lddir</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span>
<span class="w">	</span><span class="nf">ldpte</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span>
<span class="w">	</span><span class="nf">ldpte</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">	</span><span class="nf">tlbfill</span>
<span class="w">	</span><span class="nf">csrrd</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="no">LOONGARCH_CSR_TLBRSAVE</span>
<span class="w">	</span><span class="nf">ertn</span>
<span class="nf">SYM_CODE_END</span><span class="p">(</span><span class="no">handle_tlb_refill</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="three-level-page-table-refill">
<span id="id20"></span><h3><span class="section-number">4.6.1.4. </span>三级页表的示例代码<a class="headerlink" href="#three-level-page-table-refill" title="Link to this heading"></a></h3>
<p>下面是三级的PWCH和PWCL的配置，不区分是4K页还是16K页，我们给出的是4KB页配置。</p>
<p><code class="docutils literal notranslate"><span class="pre">CSR.PWCH</span> <span class="pre">=</span> <span class="pre">0x25e，</span> <span class="pre">CSR.PWCL</span> <span class="pre">=</span> <span class="pre">0x4d52c</span></code></p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">SYM_CODE_START</span><span class="p">(</span><span class="no">handle_tlb_refill</span><span class="p">)</span>
<span class="w">	</span><span class="nf">csrwr</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="no">LOONGARCH_CSR_TLBRSAVE</span>
<span class="w">	</span><span class="nf">csrrd</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="no">LOONGARCH_CSR_PGD</span>
<span class="w">	</span><span class="nf">lddir</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span>
<span class="w">	</span><span class="nf">lddir</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">	</span><span class="nf">ldpte</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span>
<span class="w">	</span><span class="nf">ldpte</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">	</span><span class="nf">tlbfill</span>
<span class="w">	</span><span class="nf">csrrd</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="no">LOONGARCH_CSR_TLBRSAVE</span>
<span class="w">	</span><span class="nf">ertn</span>
<span class="nf">SYM_CODE_END</span><span class="p">(</span><span class="no">handle_tlb_refill</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="id21">
<h3><span class="section-number">4.6.1.5. </span>四级页表的示例代码<a class="headerlink" href="#id21" title="Link to this heading"></a></h3>
<p>下面是三级的PWCH和PWCL的配置，不区分是4K页还是16K页，我们给出的是4KB页配置。</p>
<p><code class="docutils literal notranslate"><span class="pre">PWCH:</span> <span class="pre">0x267，PWCL:</span> <span class="pre">0x13e4d52c</span></code></p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">SYM_CODE_START</span><span class="p">(</span><span class="no">handle_tlb_refill</span><span class="p">)</span>
<span class="w">	</span><span class="nf">csrwr</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="no">LOONGARCH_CSR_TLBRSAVE</span>
<span class="w">	</span><span class="nf">csrrd</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="no">LOONGARCH_CSR_PGD</span>
<span class="w">	</span><span class="nf">lddir</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span>
<span class="w">	</span><span class="nf">lddir</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span>
<span class="w">	</span><span class="nf">lddir</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">	</span><span class="nf">ldpte</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span>
<span class="w">	</span><span class="nf">ldpte</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">	</span><span class="nf">tlbfill</span>
<span class="w">	</span><span class="nf">csrrd</span><span class="w">		</span><span class="no">t0</span><span class="p">,</span><span class="w"> </span><span class="no">LOONGARCH_CSR_TLBRSAVE</span>
<span class="w">	</span><span class="nf">ertn</span>
<span class="nf">SYM_CODE_END</span><span class="p">(</span><span class="no">handle_tlb_refill</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition caution">
<p class="admonition-title">小心</p>
<p><strong>注意软件重填还需要额外设置CSR.PWCH.HPTW_En = 0，表示使用软件遍历功能！！！</strong></p>
</div>
</section>
</section>
<section id="hardware-ptw">
<h2><span class="section-number">4.6.2. </span>Hardware PTW<a class="headerlink" href="#hardware-ptw" title="Link to this heading"></a></h2>
<p>软件重填比较频繁，因此会比较费事，可以将页表遍历的过程，使用硬件实现！</p>
<p>要想使用HPTW，首先我们要查看一下我们的LoongArch CPU是否支持硬件重填的功能，如下代码所示：</p>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">li.w</span><span class="w">    </span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">cpucfg</span><span class="w">  </span><span class="no">$t1</span><span class="p">,</span><span class="w"> </span><span class="no">$t0</span>
</pre></div>
</div>
<p>然后判断读取的配置字的HPTW位，具体的查看指令<code class="docutils literal notranslate"><span class="pre">cpucfg</span></code>的详细说明。</p>
<div class="admonition caution">
<p class="admonition-title">小心</p>
<p><strong>注意硬件重填还需要额外设置CSR.PWCH.HPTW_En = 1，表示使用硬件遍历功能！！！</strong></p>
<p><strong>使用硬件重填时</strong>，我们<strong>还是需要初始化PWCL和PWCH寄存器</strong>，和配置软件重填的方式一致！。</p>
</div>
</section>
<section id="id22">
<h2><span class="section-number">4.6.3. </span>页表的刷新<a class="headerlink" href="#id22" title="Link to this heading"></a></h2>
<section id="id23">
<h3><span class="section-number">4.6.3.1. </span>页表为什么需要刷新<a class="headerlink" href="#id23" title="Link to this heading"></a></h3>
<ul class="simple">
<li><p>当进程需要切换时，我们需要把TLB中旧的需要刷新下</p></li>
<li><p>当一个页的内存被回收时，需要刷新TLB，防止别的进程继续使用</p></li>
<li><p>当一个进程被销毁时，其创建的所有页表都要被回收，TLB中的也要刷新</p></li>
<li><p>当产生缺页异常do_page_fault时，要刷新到之前的旧的无效的TLB表项</p></li>
<li><p>当进程需要重新映射一个页时，需要刷新之前旧的TLB表项</p></li>
<li><p>……</p></li>
</ul>
<p>很多情况下，我们需要刷新CPU的TLB缓存。</p>
</section>
<section id="id24">
<h3><span class="section-number">4.6.3.2. </span>页表刷新的指令<a class="headerlink" href="#id24" title="Link to this heading"></a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><strong>TLBCLR指令</strong></p>
<p>指令格式： <code class="docutils literal notranslate"><span class="pre">tlbclr</span></code></p>
<p>当 CSR.TLBIDX.Index 落在 MTLB 范围内(大于等于 STLB 项数)时，执行 TLBCLR，将 MTLB 中所有<br />
G=0 且 ASID 等于 CSR.ASID.ASID 的页表项无效掉。</p>
<p>当 CSR.TLBIDX.Index 落 在 STLB 范 围内 (小 于 STLB 项 数)时 ，执 行一 条 TLBCLR ， 将 STLB 中 由<br />
CSR.TLBIDX.Index 低位所指示的那一组中所有路中等于 G=0 且 ASID 等于 CSR.ASID.ASID 的页表项无效掉。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><strong>TLBFLUSH指令</strong></p>
<p>指令格式： <code class="docutils literal notranslate"><span class="pre">tlbflush</span></code></p>
<p>当 CSR.TLBIDX.Index 落在 MTLB 范围内(大于等于 STLB 项数)时，执行 TLBFLUSH，将 MTLB 中所有<br />
页表项无效掉。</p>
<p>当 CSR.TLBIDX.Index 落在 STLB 范围内(小于 STLB 项数)时，执行一条 TLBFLUSH，将 STLB 中由<br />
CSR.TLBIDX.Index 低位所指示的那一组中所有路中的页表项无效掉。</p>
</div>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p><strong>INVTLB指令</strong></p>
<p>指令格式： <code class="docutils literal notranslate"><span class="pre">invtlb</span>&#160;&#160; <span class="pre">op,</span> <span class="pre">rj,</span> <span class="pre">rk</span></code></p>
<p>指令的三个源操作数中，op 是 5 比特立即数，用于指示操作类型。<br />
通用寄存器 rj 的[9:0]位存放无效操作所需的 ASID 信息（称为“寄存器指定 ASID”），其余比特必须填 0。</p>
<p>当 op 所指示的操作不需要 ASID 时，应将通用寄存器 rj 设置为 r0。<br />
通用寄存器 rk 中用于存放无效操作所需的虚拟地址信息（称为“寄存器指定 VA”）。</p>
<p>当 op 所指示的操作不需要虚拟地址信息时，应将通用寄存器 rk 设置为 r0。</p>
</div>
<p>下面是Op具体对应的值以及含义：</p>
<table border="1" class="docutils">
<thead>
<tr>
<th>Op对应的值</th>
<th>具体的操作描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0</td>
<td>清除所有页表项。</td>
</tr>
<tr>
<td>0x1</td>
<td>清除所有页表项。此时操作效果与 op=0 完全一致。</td>
</tr>
<tr>
<td>0x2</td>
<td>清除所有 G=1 的页表项。</td>
</tr>
<tr>
<td>0x3</td>
<td>清除所有 G=0 的页表项。</td>
</tr>
<tr>
<td>0x4</td>
<td>清除所有 G=0，且 ASID 等于寄存器指定 ASID 的页表项。</td>
</tr>
<tr>
<td>0x5</td>
<td>清除 G=0，且 ASID 等于寄存器指定 ASID，且 VA 等于寄存器指定 VA 的页表项。</td>
</tr>
<tr>
<td>0x6</td>
<td>清除所有 G=1 或 ASID 等于寄存器指定 ASID，且 VA 等于寄存器指定 VA 的页表项。</td>
</tr>
</tbody>
</table>
</section>
<section id="id25">
<h3><span class="section-number">4.6.3.3. </span>页表刷新的例子<a class="headerlink" href="#id25" title="Link to this heading"></a></h3>
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">invtlb</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="no">$zero</span><span class="p">,</span><span class="w"> </span><span class="no">$zero</span>
</pre></div>
</div>
<p>清除TLB中所有的页表项。</p>
<hr class="docutils" />
<div class="highlight-asm notranslate"><div class="highlight"><pre><span></span><span class="nf">li.d</span><span class="w">  </span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="no">IMM_ASID</span>
<span class="nf">li.d</span><span class="w">  </span><span class="no">$t1</span><span class="p">,</span><span class="w"> </span><span class="no">ADDR</span>

<span class="nf">invtlb</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="no">$t0</span><span class="p">,</span><span class="w"> </span><span class="no">$t1</span>
</pre></div>
</div>
<p>上述例子清除TLB中，ASID等于IMM_ASID，虚拟地址等于ADDR的页表项！其余的不改变。</p>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>为什么需要刷新</p></li>
<li><p>刷新的场合是什么</p></li>
<li><p>采用什么样的方式</p></li>
<li><p>进程的切换也要刷新</p></li>
<li><p>给出具体的例子，比如内核代码，
或者其他的示例代码</p></li>
</ol>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="页脚">
    <a href="dmw.html" class="btn btn-neutral float-left" title="4.4. 直接映射翻译模式" accesskey="p"
      rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> 上一页</a>
    <a href="page_table_in_kernel.html" class="btn btn-neutral float-right" title="4.7. Kernel与MMU" accesskey="n"
      rel="next">下一页 <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>

  <hr />

  <div role="contentinfo">
    <p>&#169; 版权所有 2022-2026, 龙芯中科技术有限公司。
      <span class="lastupdated">最后更新于 2026年2月10日 11:15:08.
      </span>

      <!-- 
      <span class="footer-aside">
        <a href="../../龙芯实验室文档.pdf" class="fa fa-file-pdf-o">&nbsp下载 PDF</a>
      </span>
       -->
    </p>
  </div> 

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>